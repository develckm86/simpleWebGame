<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Space Dodge - Three.js</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    html, body { height: 100%; margin: 0; background: #000; color: #e7f0ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    /* 기본 글자 크기를 반응형으로 */
    html { font-size: clamp(14px, 2.8vw, 18px); }
    body { font-size: 1rem; }
    :root {
      --btn-min: 64px;
      --btn-vw: 18vw;
      --btn-max: 110px;
    }
    /* ===== UI Grid Overlay ===== */
    .ui-grid {
      position: fixed;
      inset: 0;
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: auto auto 1fr auto;
      grid-template-areas:
        "hud"
        "hint"
        "."
        "controls";
      pointer-events: none; /* 기본 차단, 내부 컨트롤에서만 허용 */
    }

    #hud {
      grid-area: hud;
      font-size: clamp(18px, 2.8vw, 24px);
      font-weight: 600; letter-spacing: .3px;
      border-bottom-right-radius: 10px;
      justify-self: start;
      pointer-events: auto;
    }
    #hud>div {
      margin: 10px;
      padding: 10px 14px; 
      background: linear-gradient(to right, rgba(0,0,0,.65), rgba(0,0,0,0));
    }
    #hint{
      grid-area: hint;
      
    }
    #hint>div {
      text-align: right; opacity: .9; line-height: 1.4;
      background: linear-gradient(to left, rgba(0,0,0,.65), rgba(0,0,0,0));
      padding: 10px 14px; border-bottom-left-radius: 10px;
      justify-self: end;
      margin: 10px;
      pointer-events: auto;
    }
    #centerMsg {
      grid-area: centerMsg;
      text-align: center; font-weight: 800; letter-spacing: .8px;
      display: flex; align-items: center; justify-content: center;
    }
    #centerMsg>div {
      background: rgba(0,0,0,.55); padding: 18px 22px; border-radius: 12px; 
      box-shadow: 0 10px 30px rgba(0,0,0,.4);

    }
    #centerMsg h1 { margin: 0 0 8px; font-size: clamp(22px, 4vw, 36px); }
    #centerMsg p { 
      margin: 6px 0; opacity: .9;
      display: flex; align-items: center; gap: 8px;
    }
    canvas { display:block; }
    a { color: #8fd3ff; text-decoration: none; }
    /* 모바일용 오토 발사 토글 버튼 */

    #autoFireBtn.active {
      background: rgba(20,80,110,.8);
      border-color: #8fd3ff;
    }
    /* 컨트롤바 안의 오토발사 버튼은 고정 배치 해제 */
    .control-bar {
      grid-area: controls;
      display: flex; gap: 14px; align-items: center; justify-content: center;
      pointer-events: none;
      justify-self: center;
    }
    .control-bar .dpad {
      display: grid;
      grid-template-columns: repeat(3, auto);
      grid-template-rows: repeat(3, auto);
      gap: 8px; align-items: center; justify-items: center;
    }
    .control-bar .dpad button,
    .control-bar button {
      pointer-events: auto;
      background: rgba(0,0,0,.55);
      color: #e7f0ff;
      border: 1px solid rgba(143,211,255,.5);
      width: 100%; height: 100%; max-width: var(--btn-max); max-height: var(--btn-max);
      line-height: 100%;
      border-radius: 12px; font-weight: 800;
      box-shadow: 0 6px 16px rgba(0,0,0,.35);
      -webkit-tap-highlight-color: transparent;
      font-size: clamp(14px, 4.2vw, 20px);
      padding: .5em;
    }
    .control-bar .dpad button:active,
    .control-bar .actions button:active { background: rgba(20,80,110,.8); border-color: #8fd3ff; }
    .control-bar .dpad .empty { visibility: hidden; }
    .control-bar .actions { display: grid; grid-auto-rows: auto; gap: 8px; }
    /* 큰 화면에서는 상단 좌/우에 HUD/Hint, 하단 중앙에 컨트롤 배치 */
    .ui-grid {
        grid-template-columns: repeat(3, 33.3vw);
        grid-template-rows: repeat(4, 25vh);
        grid-template-areas:
          "hud . hint"
          ". centerMsg ."
          ". . ."
          ". controls .";
      }
    

    /* 모바일(터치) 환경에서는 안내문 감춤 */
    @media (hover: none) and (pointer: coarse) {
      #hint { display: none; }
    }

    @media (max-width: 420px) {
      #hud { padding: 8px 10px; }
      #hint { padding: 8px 10px; }
      .ui-grid {
        grid-template-columns: repeat(1, auto);
        grid-template-rows: repeat(4, 25vh);
        grid-template-areas:
          "hud"
          "centerMsg"
          "."
          "controls";
      }

    }

  </style>
</head>
<body>
  <div class="ui-grid">
  <div id="hud">
    <div>
      <div class="line">점수: <span id="score">0</span></div>
      <div class="line">최고점수: <span id="best">0</span></div>
      <div class="line">속도: <span id="speed">1.0</span>x</div>
    </div>
  </div>
  <div id="hint">
    <div>
    조작: ←/→ 또는 A/D 이동 · F: 발사<br/>
    스페이스: 일시정지/재개 · R: 재시작 · Shift+방향키/마우스: 시야 조정<br/>
    모바일: 화면 좌/우 터치 이동 · 오토 발사 버튼 · 하단 화살표로 시야 조작
    </div>
  </div>
  <div id="centerMsg">
    <div>
      <h1>Space Dodge</h1>
      <p>이동 : 좌우 터치, ←/→ 또는 A/D </p>
      <p>일시정지/시작 :  
        <svg
          width="24"
          height="24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <use href="src/svg/pause.svg" />
        </svg>

       버튼, 스페이스  </p>
      <p>재시작 : 
        <svg
        width="24"
        height="24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <use href="src/svg/play.svg" />
      </svg>
        버튼, R </p>
    </div>
  </div>

  <!-- 하단 컨트롤: 십자(D-Pad) + 오른쪽 액션(Start/Pause/AUTO) -->
  <div class="control-bar" aria-label="모바일 컨트롤">
    <div class="dpad" aria-label="시야 조작">
      <button id="viewOut" aria-label="zoom out"><svg
        width="24"
        height="24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <use href="src/svg/minus-circle.svg" />
      </svg></button>
      <button id="viewUp" aria-label="look up">▲</button>
      <button id="viewIn" aria-label="zoom in">
        <svg
          width="24"
          height="24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <use href="src/svg/plus-circle.svg" />
        </svg>
      </button>
      <button id="viewLeft" aria-label="look left">◀</button>
      <button id="viewOrigin" aria-label="origin">
        <svg
          width="24"
          height="24"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        >
          <use href="src/svg/eye.svg" />
        </svg>
      </button>
      <button id="viewRight" aria-label="look right">▶</button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button id="viewDown" aria-label="look down">▼</button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
    </div>
    <div class="actions">
      <button id="startBtn" type="button" aria-label="start">        <svg
        width="24"
        height="24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <use href="src/svg/play.svg" />
      </svg>
</button>
      <button id="pauseBtn" type="button" aria-label="pause"> <svg
        width="24"
        height="24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <use href="src/svg/pause.svg" />
      </svg></button>
      <button id="autoFireBtn" type="button" aria-pressed="false" aria-label="auto">AUTO</button>
    </div>
  </div>
  </div>

  <!-- Three.js ES Module CDN -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ----- 기본 세트업 -----
    const canvasContainer = document.body;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.shadowMap.enabled = true;
    canvasContainer.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000010, 50, 400);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    // 카메라는 매 프레임 플레이어를 따라가며 yaw/pitch에 의해 결정됩니다.

    // 조명
    const hemi = new THREE.HemisphereLight(0x99ccff, 0x223355, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(10, 20, 10);
    dir.castShadow = true;
    scene.add(dir);

    // ----- 우주 배경(별 입자) -----
    function createStarfield(count = 1500, depth = 800) {
      const geom = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        positions[i * 3 + 0] = (Math.random() - 0.5) * 200; // x
        positions[i * 3 + 1] = Math.random() * 120 - 20;    // y
        positions[i * 3 + 2] = -Math.random() * depth;      // z (카메라 뒤쪽)
      }
      geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      const mat = new THREE.PointsMaterial({ size: 0.8, color: 0x9ecbff });
      const points = new THREE.Points(geom, mat);
      points.userData = { depth };
      return points;
    }
    const stars = createStarfield();
    scene.add(stars);

    // 바닥 텍스처(캔버스로 생성하는 그리드/활주로 라인)
    function createRunwayTexture() {
      const c = document.createElement('canvas');
      c.width = 512; c.height = 512;
      const g = c.getContext('2d');
      // 배경
      g.fillStyle = '#0a1f2a';
      g.fillRect(0, 0, c.width, c.height);
      // 미세 노이즈 점
      g.globalAlpha = 0.06;
      for (let i = 0; i < 1200; i++) {
        const x = Math.random() * c.width;
        const y = Math.random() * c.height;
        const s = Math.random() * 1.6;
        g.fillStyle = '#103244';
        g.fillRect(x, y, s, s);
      }
      g.globalAlpha = 1.0;
      // 세로 그리드 라인
      g.strokeStyle = '#1a6c8f';
      g.lineWidth = 3;
      for (let x = 0; x <= c.width; x += 64) {
        g.beginPath(); g.moveTo(x + 0.5, 0); g.lineTo(x + 0.5, c.height); g.stroke();
      }
      // 가로 스트립(활주로 표식)
      for (let y = 40; y < c.height; y += 96) {
        g.fillStyle = '#2a9fd0';
        g.globalAlpha = 0.42;
        g.fillRect(0, y, c.width, 14);
        g.globalAlpha = 1.0;
        // 가운데 얇은 라인 강조
        g.fillStyle = '#66d3ff';
        g.fillRect(0, y + 5, c.width, 3);
      }
      // 중앙 레인 라인(점선)
      g.fillStyle = '#8fe6ff';
      for (let y = 0; y < c.height; y += 48) {
        g.fillRect(c.width/2 - 5, y + 8, 10, 20);
      }
      const tex = new THREE.CanvasTexture(c);
      if (THREE.SRGBColorSpace) tex.colorSpace = THREE.SRGBColorSpace;
      tex.needsUpdate = true;
      return tex;
    }

    // ----- 플레이어 -----
    const playerSize = new THREE.Vector3(2.2, 2.2, 2.2);
    const playerMat = new THREE.MeshStandardMaterial({ color: 0x68d5ff, metalness: 0.25, roughness: 0.45, emissive: 0x0a2a3a, emissiveIntensity: 0.25 });
    const player = new THREE.Group();
    // 코(노즈)
    const nose = new THREE.Mesh(new THREE.ConeGeometry(1.0, 2.2, 10), playerMat);
    nose.rotation.x = -Math.PI / 2; // -z 방향(나가는 방향)으로 향하도록
    nose.position.set(0, 0, -0.25);
    nose.castShadow = true;
    // 몸체
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.95, 1.6, 8), playerMat);
    body.rotation.x = -Math.PI / 2;
    body.position.set(0, 0, 0.7);
    body.castShadow = true;
    // 날개 (좌우가 끝으로 갈수록 좁아지는 트라페조이드 형태)
    const wingMat = new THREE.MeshStandardMaterial({ color: 0x4ac8ff, metalness: 0.2, roughness: 0.5 });
    function makeTaperedWing(side = 1) {
      // side: +1 오른쪽, -1 왼쪽
      const geo = new THREE.BoxGeometry(1.2, 0.14, 1.3); // 더 넓고 두꺼운 날개 (콩코드 느낌)
      const pos = geo.attributes.position;
      pos.needsUpdate = true;
      // x 기준으로 끝으로 갈수록 z(코드 길이)를 줄여 날개 끝이 좁아지는 느낌
      // root(기체 쪽) 보존, tip(끝)에서 0.6배로 축소
      const v = new THREE.Vector3();
      let minX = Infinity, maxX = -Infinity;
      for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);
        minX = Math.min(minX, v.x);
        maxX = Math.max(maxX, v.x);
      }
      for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);
        const t = (side > 0)
          ? (v.x - minX) / (maxX - minX) // 오른쪽 날개는 +x가 tip
          : (maxX - v.x) / (maxX - minX); // 왼쪽 날개는 -x가 tip
        const factor = 1.0 - 0.8 * Math.max(0, Math.min(1, t)); // 1.0 -> 0.6로 선형 축소
        v.z *= factor;
        pos.setXYZ(i, v.x, v.y, v.z);
      }
      geo.computeVertexNormals();
      const mesh = new THREE.Mesh(geo, wingMat);
      mesh.castShadow = true;
      // 스윕백 각도를 약간 완화하고, 몸통에 밀착되도록 위치 조정
      mesh.rotation.y = side * -0.08;
      mesh.position.set(side * 1.2, 0, 0.65);
      return mesh;
    }
    const leftWing = makeTaperedWing(-1);
    const rightWing = makeTaperedWing(1);
    // 엔진 글로우 (따뜻한 붉은빛)
    const engineMat = new THREE.MeshStandardMaterial({ color: 0xffb3a1, emissive: 0xff5a3d, emissiveIntensity: 1.0 });
    const engine = new THREE.Mesh(new THREE.SphereGeometry(0.22, 10, 10), engineMat);
    engine.position.set(0, 0, 1.5);
    // 엔진 불꽃(애니메이션) - 더 크고 붉은 색감
    const flameMat = new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0xff3333, emissiveIntensity: 1.35, transparent: true, opacity: 0.9 });
    const flame = new THREE.Mesh(new THREE.ConeGeometry(0.55, 1.8, 12), flameMat);
    flame.rotation.x = Math.PI / 2; // +z(후방)으로 뻗는 불꽃
    flame.position.set(0, 0, 2.2);
    flame.castShadow = false;
    player.add(nose, body, leftWing, rightWing, engine, flame);
    player.userData.flame = flame;
    // 비행 고도 약간 낮춤
    player.position.set(0, 1.6, 0);
    scene.add(player);

    // 바닥(활주로 텍스처 + 스크롤)
    const runwayTex = createRunwayTexture();
    runwayTex.wrapS = THREE.RepeatWrapping;
    runwayTex.wrapT = THREE.RepeatWrapping;
    runwayTex.repeat.set(2, 10);
    runwayTex.anisotropy = 4;
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(24, 1000),
      new THREE.MeshBasicMaterial({ color: 0xffffff, map: runwayTex })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.z = -300;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // ----- 적 블록 풀 -----
    const ENEMY_POOL_SIZE = 50;
    const enemyGeo = new THREE.BoxGeometry(2.2, 2.2, 2.2);
    const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff8fa3, metalness: 0.25, roughness: 0.45, emissive: 0x3c0a0f, emissiveIntensity: 0.35 });
    const enemies = [];
    for (let i = 0; i < ENEMY_POOL_SIZE; i++) {
      const m = new THREE.Mesh(enemyGeo, enemyMat.clone()); // 개별 색상 변경 가능하도록 clone
      m.castShadow = true;
      m.visible = false;
      m.position.set(0, 2.5, -200);
      scene.add(m);
      enemies.push(m);
    }

    // 스폰 레인(좌표)
    const LANES = [-6, -3, 0, 3, 6];

    // ----- 상태 -----
    let isRunning = false;
    let isDead = false;
    let score = 0;
    let best = Number(localStorage.getItem("space_dodge_best") || 0);
    let baseSpeed = 0.6;      // 적의 기본 전진 속도
    let speedScale = 1.0;     // 시간 경과에 따라 증가
    let spawnEvery = 550;     // 적 생성 간격(ms) - 감소 빈도 낮춤
    let lastSpawn = 0;
    let lastTime = performance.now();
    // 플레이어 기울기(롤) 상태
    let playerRoll = 0;       // z축 회전(좌우 기울기)
    // 총알(미사일) 풀
    const BULLET_POOL_SIZE = 40;
    const bulletGeo = new THREE.CylinderGeometry(0.18, 0.28, 1.2, 8);
    const bulletMat = new THREE.MeshStandardMaterial({ color: 0x9be8ff, emissive: 0x66ccff, emissiveIntensity: 1.8, metalness: 0.1, roughness: 0.3 });
    const bullets = [];
    for (let i = 0; i < BULLET_POOL_SIZE; i++) {
      const b = new THREE.Mesh(bulletGeo, bulletMat);
      b.rotation.x = -Math.PI / 2; // -Z로 날아가도록
      b.visible = false;
      b.userData.vz = -1.6; // 기본 속도 (전방 방향)
      // 글로우(발광) 이펙트: 약간 큰 실린더를 자식으로 붙여 가산합성
      const glowGeo = new THREE.CylinderGeometry(0.28, 0.38, 1.4, 8);
      const glowMat = new THREE.MeshBasicMaterial({ color: 0x9be8ff, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      // 부모(bullet)가 이미 -Math.PI/2 회전되어 있어 자식은 추가 회전 불필요
      glow.rotation.x = 0;
      b.add(glow);
      scene.add(b);
      bullets.push(b);
    }
    let fireCooldown = 0;
    const fireInterval = 180; // ms
    // 카메라 제어 상태
    let camYaw = 0.0;           // 좌우 회전 (라디안)
    let camPitch = 0.28;        // 상하 (라디안, 위로 양수)
    let camDist = 19;           // 플레이어로부터 거리
    const camMinDist = 10;
    const camMaxDist = 32;
    const camTargetOffset = new THREE.Vector3(0, 1.8, 0); // 플레이어 위를 보도록

    // HUD DOM
    const $score = document.getElementById("score");
    const $best = document.getElementById("best");
    const $speed = document.getElementById("speed");
    const $center = document.getElementById("centerMsg");
    $best.textContent = best.toString();
    showCenter(true);

    // ----- 입력 -----
    const input = { left: false, right: false };
    let autoFireEnabled = false;
    window.addEventListener("keydown", (e) => {
      // Shift + 방향키 => 카메라 조정
      if (e.shiftKey) {
        if (e.code === "ArrowLeft") { camYaw -= 0.08; e.preventDefault(); return; }
        if (e.code === "ArrowRight") { camYaw += 0.08; e.preventDefault(); return; }
        if (e.code === "ArrowUp") { camPitch = Math.min(1.2, camPitch + 0.06); e.preventDefault(); return; }
        if (e.code === "ArrowDown") { camPitch = Math.max(-0.05, camPitch - 0.06); e.preventDefault(); return; }
      }
      if (e.code === "ArrowLeft" || e.code === "KeyA") input.left = true;
      if (e.code === "ArrowRight" || e.code === "KeyD") input.right = true;
      if (e.code === "KeyF") { // 발사
        e.preventDefault();
        tryFire();
        return;
      }
      if (e.code === "Space") {
        e.preventDefault();
        toggleRun();
      }
      if (e.code === "KeyR") restart();
    });
    window.addEventListener("keyup", (e) => {
      if (e.code === "ArrowLeft" || e.code === "KeyA") input.left = false;
      if (e.code === "ArrowRight" || e.code === "KeyD") input.right = false;
    });

    // 터치로 좌우 이동 (화면 중앙 기준)
    function setTouchMovement(x) {
      const mid = window.innerWidth / 2;
      input.left = x < mid;
      input.right = x >= mid;
    }
    window.addEventListener("touchstart", (e) => {
      // 컨트롤바 영역 터치는 이동 입력 무시
      if (e.target && (e.target.closest && e.target.closest('.control-bar'))) return;
      if (e.touches && e.touches.length > 0) {
        setTouchMovement(e.touches[0].clientX);
      }
      e.preventDefault();
    }, { passive: false });
    window.addEventListener("touchmove", (e) => {
      if (e.target && (e.target.closest && e.target.closest('.control-bar'))) return;
      if (e.touches && e.touches.length > 0) {
        setTouchMovement(e.touches[0].clientX);
      }
      e.preventDefault();
    }, { passive: false });
    function clearTouchMovement() {
      input.left = false; input.right = false;
    }
    window.addEventListener("touchend", () => { clearTouchMovement(); }, { passive: true });
    window.addEventListener("touchcancel", () => { clearTouchMovement(); }, { passive: true });

    // 마우스 드래그로 카메라 회전
    const mouse = { dragging: false, lastX: 0, lastY: 0 };
    window.addEventListener("mousedown", (e) => {
      mouse.dragging = true; mouse.lastX = e.clientX; mouse.lastY = e.clientY; e.preventDefault();
    });
    window.addEventListener("mousemove", (e) => {
      if (!mouse.dragging) return;
      const dx = e.clientX - mouse.lastX;
      const dy = e.clientY - mouse.lastY;
      mouse.lastX = e.clientX; mouse.lastY = e.clientY;
      camYaw += dx * 0.005;
      camPitch = Math.max(-0.05, Math.min(1.2, camPitch - dy * 0.003));
    });
    window.addEventListener("mouseup", () => { mouse.dragging = false; });
    window.addEventListener("mouseleave", () => { mouse.dragging = false; });
    // 휠로 줌
    window.addEventListener("wheel", (e) => {
      e.preventDefault();
      camDist = Math.max(camMinDist, Math.min(camMaxDist, camDist + Math.sign(e.deltaY) * 1.2));
    }, { passive: false });

    // 오토 발사 토글 버튼
    const $autoFireBtn = document.getElementById("autoFireBtn");
    function updateAutoFireBtn() {
      $autoFireBtn.classList.toggle("active", autoFireEnabled);
      $autoFireBtn.textContent = 'AUTO';
      $autoFireBtn.setAttribute('aria-pressed', String(autoFireEnabled));
    }
    $autoFireBtn.addEventListener("click", () => {
      autoFireEnabled = !autoFireEnabled;
      updateAutoFireBtn();
    });
    updateAutoFireBtn();

    // 하단 시야 조작 버튼 로직 (누를 때마다 조금씩 이동, 길게 누르면 반복)
    const btnUp = document.getElementById('viewUp');
    const btnDown = document.getElementById('viewDown');
    const btnLeft = document.getElementById('viewLeft');
    const btnRight = document.getElementById('viewRight');
    const btnOut = document.getElementById('viewOut');
    const btnIn = document.getElementById('viewIn');
    const btnOrigin = document.getElementById('viewOrigin');
    const STEP = { yaw: 0.06, pitch: 0.05, dist: 1.2 };
    function clampPitch(v) { return Math.max(-0.05, Math.min(1.2, v)); }
    function clampDist(v) { return Math.max(camMinDist, Math.min(camMaxDist, v)); }
    function nudge(action) {
      switch (action) {
        case 'up':    camPitch = clampPitch(camPitch + STEP.pitch); break;
        case 'down':  camPitch = clampPitch(camPitch - STEP.pitch); break;
        case 'left':  camYaw -= STEP.yaw; break;
        case 'right': camYaw += STEP.yaw; break;
        case 'out':   camDist = clampDist(camDist + STEP.dist); break;
        case 'in':    camDist = clampDist(camDist - STEP.dist); break;
        case 'origin': camYaw = 0; camPitch = 0.28; camDist = 19; break;
      }
    }
    function bindNudge(btn, action) {
      let timer;
      const start = (e) => {
        e.stopPropagation();
        nudge(action);
        clearInterval(timer);
        timer = setInterval(() => nudge(action), 100);
      };
      const stop = () => { clearInterval(timer); };
      btn.addEventListener('click', (e) => { e.stopPropagation(); nudge(action); });
      btn.addEventListener('mousedown', start);
      btn.addEventListener('mouseup', stop);
      btn.addEventListener('mouseleave', stop);
      btn.addEventListener('touchstart', start, { passive: true });
      btn.addEventListener('touchend', stop, { passive: true });
      btn.addEventListener('touchcancel', stop);
    }
    bindNudge(btnUp, 'up');
    bindNudge(btnDown, 'down');
    bindNudge(btnLeft, 'left');
    bindNudge(btnRight, 'right');
    bindNudge(btnOut, 'out');
    bindNudge(btnIn, 'in');
    bindNudge(btnOrigin, 'origin');
    // 시작/정지 버튼
    const $startBtn = document.getElementById('startBtn');
    const $pauseBtn = document.getElementById('pauseBtn');
    $startBtn.addEventListener('click', () => {
      if (isDead) restart();
      isRunning = true;
      showCenter(false);
    });
    $pauseBtn.addEventListener('click', () => {
      if (isDead) return;
      isRunning = false;
      showCenter(true, '일시정지', '시작 버튼으로 재개');
    });

    function toggleRun() {
      if (isDead) return;
      isRunning = !isRunning;
      showCenter(!isRunning);
    }

    function showCenter(show, title, desc) {
      if (show) {
        if (title) {
          $center.querySelector("h1").textContent = title;
        }
        if (desc) {
          $center.querySelectorAll("p")[0].textContent = desc;
        }
        $center.style.display = "flex";
      } else {
        $center.style.display = "none";
      }
    }

    function restart() {
      // 초기화
      isDead = false;
      isRunning = false;
      score = 0;
      speedScale = 1.0;
      baseSpeed = 0.6;
      spawnEvery = 550; // 재시작 시에도 여유 있게 시작
      $score.textContent = "0";
      $speed.textContent = speedScale.toFixed(1) + "x";
      // 적 리셋
      for (const e of enemies) {
        e.visible = false;
        e.position.z = -200;
        e.userData.hp = 0;
      }
      // 총알 리셋
      for (const b of bullets) {
        b.visible = false;
        b.position.z = 0;
      }
      fireCooldown = 0;
      // 플레이어 위치
      player.position.x = 0;
      // 롤 초기화
      playerRoll = 0;
      player.rotation.z = 0;
      showCenter(true, "Space Dodge", "←/→ 또는 A/D로 좌우 이동");
    }

    // ----- 유틸 -----
    function spawnEnemy() {
      const e = enemies.find(o => !o.visible);
      if (!e) return;
      e.visible = true;
      const laneX = LANES[Math.floor(Math.random() * LANES.length)];
      const sizeY = 1.8 + Math.random() * 2.2;   // 약간 다양한 높이
      e.scale.set(1, sizeY / 2.2, 1);
      // 타입 지정: 1타 격파(작고 붉은색) vs 3타 격파(크고 주황색)
      if (Math.random() < 0.55) {
        // 1타
        e.userData.hp = 1;
        e.material.color.setHex(0xff8ea0); // 더 밝은 코랄톤
        e.material.emissive.setHex(0x5a0f12);
        e.material.emissiveIntensity = 0.4;
        // 기본 크기 유지
      } else {
        // 3타
        e.userData.hp = 3;
        e.material.color.setHex(0xffc14a); // 더 밝은 오렌지/골드
        e.material.emissive.setHex(0x5a2a00);
        e.material.emissiveIntensity = 0.35;
        e.scale.multiplyScalar(1.25);
      }
      e.position.set(laneX, 2.5, -280 - Math.random() * 60);
      e.userData.passed = false;
    }

    // 발사 유틸
    function tryFire() {
      const nowT = performance.now();
      if (nowT - (tryFire.last || 0) < fireInterval || fireCooldown > 0) return;
      tryFire.last = nowT;
      const b = bullets.find(o => !o.visible);
      if (!b) return;
      b.visible = true;
      // 플레이어 전방(-Z)으로 조금 앞쪽에서 시작
      b.position.set(player.position.x, player.position.y, player.position.z - 1.3);
      b.userData.vz = -2.2 - speedScale * 0.2;
      fireCooldown = fireInterval;
    }

    function aabbIntersect(aPos, aSize, bPos, bSize) {
      return Math.abs(aPos.x - bPos.x) * 2 < (aSize.x + bSize.x) &&
             Math.abs(aPos.y - bPos.y) * 2 < (aSize.y + bSize.y) &&
             Math.abs(aPos.z - bPos.z) * 2 < (aSize.z + bSize.z);
    }

    function updateHUD() {
      $score.textContent = Math.floor(score).toString();
      $speed.textContent = speedScale.toFixed(1) + "x";
    }

    // ----- 메인 루프 -----
    function tick(now) {
      const dt = Math.min(50, now - lastTime); // ms
      lastTime = now;

      // 별 이동(카메라 쪽으로)
      const starPos = stars.geometry.attributes.position;
      const depth = stars.userData.depth;
      for (let i = 0; i < starPos.count; i++) {
        const z = starPos.getZ(i) + (0.05 + speedScale * 0.02) * (dt / 16.67);
        if (z > 10) {
          starPos.setZ(i, -Math.random() * depth - 100);
          starPos.setX(i, (Math.random() - 0.5) * 200);
        } else {
          starPos.setZ(i, z);
        }
      }
      starPos.needsUpdate = true;

      // 입력에 따른 플레이어 좌우 이동
      if (isRunning && !isDead) {
        const move = 0.02 * dt * 0.6 * (1 + (speedScale - 1) * 0.2);
        if (input.left)  player.position.x -= move;
        if (input.right) player.position.x += move;
        // 레일 범위 제한
        player.position.x = Math.max(-7.5, Math.min(7.5, player.position.x));
      }

      // 좌/우 이동 입력에 따른 기체 롤링(기울기)
      {
        const maxRoll = 0.28; // 최대 기울기(라디안)
        const dir = (input.left ? 1 : 0) + (input.right ? -1 : 0); // left:+1, right:-1
        const targetRoll = (isRunning && !isDead) ? maxRoll * dir : 0;
        // 부드럽게 보간
        playerRoll += (targetRoll - playerRoll) * 0.12;
        player.rotation.z = playerRoll;
      }

      // 시야 조작은 버튼 클릭/홀드에 의해 단계적으로 반영됨

      // 팔로우 카메라 포지셔닝: 플레이어 기준으로 궤도 배치 후 플레이어를 바라봄
      {
        const target = new THREE.Vector3().copy(player.position).add(camTargetOffset);
        const cosP = Math.cos(camPitch);
        const offsetX = Math.sin(camYaw) * cosP * camDist;
        const offsetY = Math.sin(camPitch) * camDist;
        const offsetZ = Math.cos(camYaw) * cosP * camDist;
        camera.position.set(target.x + offsetX, target.y + offsetY, target.z + offsetZ);
        camera.lookAt(target);
      }

      // 발사 쿨다운 감소
      if (fireCooldown > 0) fireCooldown = Math.max(0, fireCooldown - dt);

      // 오토 발사
      if (isRunning && !isDead && autoFireEnabled) {
        tryFire();
      }

      // 총알 업데이트 및 적과의 충돌 처리
      if (isRunning && !isDead) {
        const bulletSize = new THREE.Vector3(0.4, 0.4, 1.2);
        for (const b of bullets) {
          if (!b.visible) continue;
          b.position.z += b.userData.vz * (dt / 16.67);
          if (b.position.z < -350) { b.visible = false; continue; }
          // 적과 충돌 체크
          for (const e of enemies) {
            if (!e.visible) continue;
            const enemySize = new THREE.Vector3(2.2, 2.2 * e.scale.y, 2.2);
            if (aabbIntersect(b.position, bulletSize, e.position, enemySize)) {
              // 피격 처리
              b.visible = false;
              e.userData.hp = Math.max(0, (e.userData.hp || 1) - 1);
              if (e.userData.hp <= 0) {
                e.visible = false;
                e.position.z = -200;
                score += 10; // 파괴 보상
              } else {
                score += 3; // 피격 보상(부분 타격)
              }
              break;
            }
          }
        }
      }

      // 활주로 텍스처 스크롤(전진감) - 일시정지/사망 시 정지
      if (runwayTex && isRunning && !isDead) {
        // 속도에 비례해서 더 빨리 스크롤 (약하게)
        runwayTex.offset.y += (0.006 + speedScale * 0.003) * (dt / 16.67);
      }

      // 엔진 불꽃 애니메이션
      if (player.userData.flame) {
        const f = player.userData.flame;
        const t = now * 0.02;
        const len = 0.85 + Math.sin(t) * 0.05 + Math.random() * 0.03;
        f.scale.set(1, len, 1);
        f.material.emissiveIntensity = 0.8 + Math.random() * 0.3;
        f.material.opacity = 0.55 + Math.random() * 0.15;
      }

      // 적 이동/충돌/점수
      if (isRunning && !isDead) {
        const enemySpeed = (baseSpeed + speedScale * 0.4) * (dt / 16.67);
        for (const e of enemies) {
          if (!e.visible) continue;
          e.position.z += enemySpeed; // 카메라 쪽으로
          // 충돌 체크 (박스 적: Y축 스케일 반영)
          if (aabbIntersect(player.position, playerSize, e.position, new THREE.Vector3(2.2, 2.2 * e.scale.y, 2.2))) {
            isDead = true;
            isRunning = false;
            best = Math.max(best, Math.floor(score));
            localStorage.setItem("space_dodge_best", String(best));
            document.getElementById("best").textContent = best.toString();
            showCenter(true, "충돌!", "R: 재시작 · 스페이스: 일시정지/재개");
          }
          // 지나가면 점수
          if (!e.userData.passed && e.position.z > player.position.z + 1.5) {
            e.userData.passed = true;
            score += 10 * speedScale;
          }
          // 화면 앞을 지나면 리셋
          if (e.position.z > 40) {
            e.visible = false;
            e.position.z = -200;
          }
        }
        // 난이도 상승
        speedScale += 0.0006 * (dt / 16.67);      // 천천히 가속
        // 스폰 주기를 너무 짧아지지 않게 상향 조정
        spawnEvery = Math.max(320, 550 - speedScale * 45); // 최소 간격 상향, 기본 간격 증가
        updateHUD();
      }

      // 스폰 타이밍
      if (isRunning && !isDead) {
        if (now - lastSpawn > spawnEvery) {
          lastSpawn = now;
          // 한 번에 1~2개 스폰으로 랜덤성
          const batch = Math.random() < 0.05 ? 2 : 1; // 2개 동시 스폰 확률 감소
          for (let i = 0; i < batch; i++) spawnEnemy();
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame((t) => { lastTime = t; tick(t); });

    // 반응형
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 첫 입력 시 바로 시작하고 싶다면 아래 주석 해제
    // toggleRun();

  </script>
</body>
</html>