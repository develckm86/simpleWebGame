<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Space Dodge - Three.js</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <style>
    html, body { height: 100%; margin: 0; background: #000; color: #e7f0ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    /* ê¸°ë³¸ ê¸€ì í¬ê¸°ë¥¼ ë°˜ì‘í˜•ìœ¼ë¡œ */
    html { font-size: clamp(14px, 2.8vw, 18px); }
    body { font-size: 1rem; }
    :root {
      --btn-min: 64px;
      --btn-vw: 18vw;
      --btn-max: 110px;
    }
    /* iframe ë‚´ì—ì„œ ì‘ì•„ì§€ëŠ” ë¬¸ì œë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•œ ì„ë² ë””ë“œ ìŠ¤ì¼€ì¼ ì—… */
    body.embedded {
      --btn-min: 80px;
      --btn-vw: 28vw;
      --btn-max: 160px;
    }
    /* ===== UI Grid Overlay ===== */
    .ui-grid {
      position: fixed;
      inset: 0;
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: auto auto 1fr auto;
      grid-template-areas:
        "hud"
        "hint"
        "."
        "controls";
      pointer-events: none; /* ê¸°ë³¸ ì°¨ë‹¨, ë‚´ë¶€ ì»¨íŠ¸ë¡¤ì—ì„œë§Œ í—ˆìš© */
      z-index: 10; /* ìº”ë²„ìŠ¤ ìœ„ì— ì˜¤ë„ë¡ */
    }

    #hud {
      grid-area: hud;
      font-size: clamp(18px, 2.8vw, 24px);
      font-weight: 600; letter-spacing: .3px;
      border-bottom-right-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }
    #hud>div {
      margin: 10px;
      padding: 10px 14px; 
      background: linear-gradient(to right, rgba(0,0,0,.65), rgba(0,0,0,0));
    }
    #hint{
      grid-area: hint;
      display: flex; align-items: center;
      justify-content: center;
    }
    #hint>div {
      opacity: .9; line-height: 1.4;
      background: linear-gradient(to left, rgba(0,0,0,.65), rgba(0,0,0,0));
      pointer-events: auto;
      gap: 10px;
    }
    #hint .fs-btn {
      pointer-events: auto;
      background: transparent; color: #e7f0ff; border: 1px solid rgba(143,211,255,.6);
      border-radius: 12px; padding: 10px 16px; font-weight: 800;
      font-size: clamp(18px, 3.8vw, 28px);
      box-shadow: 0 6px 16px rgba(0,0,0,.35);
    }
    #centerMsg {
      grid-area: centerMsg;
      text-align: center; font-weight: 800; letter-spacing: .8px;
      display: flex; align-items: center; justify-content: center;
    }
    #centerMsg>div {
      background: rgba(0,0,0,.55); padding: 18px 22px; border-radius: 12px; 
      box-shadow: 0 10px 30px rgba(0,0,0,.4);

    }
    /* iOS ë“±ì—ì„œ ì „ì²´í™”ë©´ ëŒ€ì²´ ëª¨ë“œ */
    body.pseudo-fullscreen { height: 100dvh; overflow: hidden; }
    body.pseudo-fullscreen canvas { position: fixed !important; inset: 0; width: 100vw !important; height: 100dvh !important; z-index: 0; }
    #centerMsg h1 { margin: 0 0 8px; font-size: clamp(22px, 4vw, 36px); }
    #centerMsg p { 
      margin: 6px 0; opacity: .9;
      display: flex; align-items: center; gap: 8px;
    }
    canvas { display:block; }
    a { color: #8fd3ff; text-decoration: none; }
    /* ëª¨ë°”ì¼ìš© ì˜¤í†  ë°œì‚¬ í† ê¸€ ë²„íŠ¼ */

    #autoFireBtn.active {
      background: rgba(20,80,110,.8);
      border-color: #8fd3ff;
    }
    /* ì»¨íŠ¸ë¡¤ë°” ì•ˆì˜ ì˜¤í† ë°œì‚¬ ë²„íŠ¼ì€ ê³ ì • ë°°ì¹˜ í•´ì œ */
    .control-bar {
      grid-area: controls;
      display: flex; gap: 14px; align-items: start; justify-content: center;
      pointer-events: none;
      justify-self: center;
    }
    .control-bar .dpad {
      display: grid;
      grid-template-columns: repeat(3, auto);
      grid-template-rows: repeat(3, auto);
      gap: 8px; align-items: center; justify-items: center;
    }
    .control-bar .dpad button,
    .control-bar button {
      pointer-events: auto;
      background: rgba(0,0,0,.55);
      color: #e7f0ff;
      border: 1px solid rgba(143,211,255,.5);
      width: 100%; height: 100%; max-width: var(--btn-max); max-height: var(--btn-max);
      line-height: 100%;
      border-radius: 12px; font-weight: 800;
      box-shadow: 0 6px 16px rgba(0,0,0,.35);
      -webkit-tap-highlight-color: transparent;
      font-size: clamp(14px, 4.2vw, 20px);
      padding: .5em;
    }
    body.embedded .control-bar button {
      font-size: clamp(16px, 5vw, 22px);
    }
    .control-bar .dpad button:active,
    .control-bar .actions button:active { background: rgba(20,80,110,.8); border-color: #8fd3ff; }
    .control-bar .dpad .empty { visibility: hidden; }
    .control-bar .actions { display: grid; grid-auto-rows: auto; gap: 8px; }
    /* í° í™”ë©´ì—ì„œëŠ” ìƒë‹¨ ì¢Œ/ìš°ì— HUD/Hint, í•˜ë‹¨ ì¤‘ì•™ì— ì»¨íŠ¸ë¡¤ ë°°ì¹˜ */
    .ui-grid {
        grid-template-columns: repeat(3, 33.3vw);
        grid-template-rows: repeat(4, 25vh);
        grid-template-areas:
        "hud . hint"
        ". centerMsg ."
        ". . ."
        ". controls .";
      }
    

    /* ëª¨ë°”ì¼ì—ì„œë„ ì „ì²´í™”ë©´ ë²„íŠ¼ì´ ë³´ì´ë„ë¡ #hintëŠ” ìˆ¨ê¸°ì§€ ì•ŠìŒ */
    /* @media (hover: none) and (pointer: coarse) {
      #hint { display: none; }
    } */

    @media (max-width: 420px) {
      #hud { padding: 8px 10px; }
      #hint { padding: 8px 10px; }
      .ui-grid {
        grid-template-columns: repeat(3, auto);
        grid-template-rows: repeat(4, 25vh);
        grid-template-areas:
          "hud . hint"
          "centerMsg centerMsg centerMsg"
          ". . ."
          "controls controls controls";
      }

    }

  </style>
</head>
<body>
  <div class="ui-grid">
  <div id="hud">
    <div class="hud-bar">
      <div class="hud-left">
        <div class="line">ì ìˆ˜: <span id="score">0</span></div>
        <div class="line">ìµœê³ ì ìˆ˜: <span id="best">0</span></div>
        <div class="line">ì†ë„: <span id="speed">1.0</span>x</div>
        <div class="line">ì´ë™ê±°ë¦¬: <span id="distance">0.0</span></div>
        <div class="line">í•œ ë²ˆì— ë°œì‚¬: <span id="missiles">1</span>ë°œ (íšë“: <span id="missilesCollected">0</span>)</div>
      </div>
    </div>
  </div>
  <div id="hint">
    <div>
      <button id="fsBtn" class="fs-btn" type="button" aria-label="fullscreen" title="ì „ì²´ í™”ë©´"> â›¶ </button>
    </div>
  </div>
  <div id="centerMsg">
    <div>
      <h1>Space Dodge</h1>
      <p>ì´ë™ : ì¢Œìš° í„°ì¹˜, â†/â†’ ë˜ëŠ” A/D </p>
      <p>ì¼ì‹œì •ì§€/ì‹œì‘ :  â¸ ë²„íŠ¼, ìŠ¤í˜ì´ìŠ¤  </p>
      <p>ì¬ì‹œì‘ : â–¶ ë²„íŠ¼, R </p>
    </div>
  </div>
  <!-- í•˜ë‹¨ ì»¨íŠ¸ë¡¤: ì‹­ì(D-Pad) + ì˜¤ë¥¸ìª½ ì•¡ì…˜(Start/Pause/AUTO) -->
  <div class="control-bar" aria-label="ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤">
    <div class="dpad" aria-label="ì‹œì•¼ ì¡°ì‘">
      <button id="viewOut" aria-label="zoom out">â–</button>
      <button id="viewUp" aria-label="look up">â–²</button>
      <button id="viewIn" aria-label="zoom in">â•</button>
      <button id="viewLeft" aria-label="look left">â—€</button>
      <button id="viewOrigin" aria-label="origin">â—‰</button>
      <button id="viewRight" aria-label="look right">â–¶</button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button id="viewDown" aria-label="look down">â–¼</button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
    </div>
    <div class="actions">
      <button id="startBtn" type="button" aria-label="start"> â–¶ </button>
      <button id="pauseBtn" type="button" aria-label="pause"> â¸ </button>
      <button id="autoFireBtn" type="button" aria-pressed="false" aria-label="auto">AUTO</button>
    </div>
  </div>
  </div>

  <!-- Three.js ES Module CDN -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ----- ê¸°ë³¸ ì„¸íŠ¸ì—… -----
    const canvasContainer = document.body;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.shadowMap.enabled = true;
    canvasContainer.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000010, 50, 400);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    // ì¹´ë©”ë¼ëŠ” ë§¤ í”„ë ˆì„ í”Œë ˆì´ì–´ë¥¼ ë”°ë¼ê°€ë©° yaw/pitchì— ì˜í•´ ê²°ì •ë©ë‹ˆë‹¤.

    // ì¡°ëª…
    const hemi = new THREE.HemisphereLight(0x99ccff, 0x223355, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(10, 20, 10);
    dir.castShadow = true;
    scene.add(dir);

    // ----- ìš°ì£¼ ë°°ê²½(ë³„ ì…ì) -----
    function createStarfield(count = 1500, depth = 800) {
      const geom = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      const sizes = new Float32Array(count);
      const colors = new Float32Array(count * 3);
      const minComponent = 0xcc / 0xff; // ìµœì†Œ ë°ê¸° (hex CC)
      for (let i = 0; i < count; i++) {
        const idx3 = i * 3;
        positions[idx3 + 0] = (Math.random() - 0.5) * 200; // x
        positions[idx3 + 1] = Math.random() * 120 - 20;    // y
        positions[idx3 + 2] = -Math.random() * depth;      // z (ì¹´ë©”ë¼ ë’¤ìª½)
        sizes[i] = 1.8 + Math.random() * 2.2;               // ì…ìë³„ ì‚¬ì´ì¦ˆ (ìŠ¤í¬ë¦° ê³µê°„ ê¸°ì¤€)

        let r = minComponent + Math.random() * (1 - minComponent);
        let g = minComponent + Math.random() * (1 - minComponent);
        let b = minComponent + Math.random() * (1 - minComponent);
        const warmShift = Math.random() * 0.08;             // ì‚´ì§ ë”°ëœ»í•œ ìƒ‰ê° ìœ ì§€
        r = Math.min(1, r + warmShift * 0.8);
        g = Math.min(1, g + warmShift);
        b = Math.max(minComponent, b - warmShift * 0.5);

        colors[idx3 + 0] = r;
        colors[idx3 + 1] = g;
        colors[idx3 + 2] = b;
      }
      geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geom.setAttribute("aSize", new THREE.BufferAttribute(sizes, 1));
      geom.setAttribute("aColor", new THREE.BufferAttribute(colors, 3));

      const mat = new THREE.ShaderMaterial({
        uniforms: {
          uPixelRatio: { value: renderer.getPixelRatio() }
        },
        vertexShader: `
          attribute float aSize;
          attribute vec3 aColor;
          uniform float uPixelRatio;
          varying vec3 vColor;

          void main() {
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            float scaledSize = aSize * uPixelRatio;
            gl_PointSize = scaledSize * (300.0 / -mvPosition.z);
            vColor = aColor;
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;

          void main() {
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            float alpha = smoothstep(0.5, 0.0, dist);
            gl_FragColor = vec4(vColor, alpha);
          }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      const points = new THREE.Points(geom, mat);
      points.userData = { depth };
      return points;
    }
    const stars = createStarfield();
    scene.add(stars);

    // ----- ì‚¬ìš´ë“œ -----
    const audio = (() => {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) {
        return { playFire() {}, playBreak() {}, playStart() {}, resume() {} };
      }
      let ctx = null;
      let masterGain = null;
      let noiseBuffer = null;

      function ensureCtx() {
        if (ctx) return ctx;
        try {
          ctx = new AudioCtx();
          masterGain = ctx.createGain();
          masterGain.gain.value = 0.5;
          masterGain.connect(ctx.destination);
        } catch (err) {
          console.warn("Audio init failed", err);
          ctx = null;
        }
        return ctx;
      }

      function ensureNoiseBuffer(duration = 1.0) {
        const c = ensureCtx();
        if (!c) return null;
        if (noiseBuffer) return noiseBuffer;
        const length = Math.ceil(c.sampleRate * duration);
        noiseBuffer = c.createBuffer(1, length, c.sampleRate);
        const data = noiseBuffer.getChannelData(0);
        for (let i = 0; i < length; i++) {
          const fade = 1 - i / length;
          data[i] = (Math.random() * 2 - 1) * fade;
        }
        return noiseBuffer;
      }

      function createEnv(total, opts = {}) {
        const c = ensureCtx();
        if (!c || !masterGain) return null;
        const now = c.currentTime + 0.001;
        const attack = opts.attack ?? 0.01;
        const release = opts.release ?? 0.25;
        const peak = opts.peak ?? 0.9;
        const sustain = opts.sustain ?? 0.4;
        const sustainTime = Math.max(0, total - attack - release);
        const gain = c.createGain();
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.linearRampToValueAtTime(peak, now + attack);
        gain.gain.linearRampToValueAtTime(peak * sustain, now + attack + sustainTime);
        gain.gain.linearRampToValueAtTime(0.0001, now + attack + sustainTime + release);
        gain.connect(masterGain);
        return { ctx: c, gain, start: now, stop: now + attack + sustainTime + release };
      }

      function playFire(burst = 1) {
        const env = createEnv(0.22, {
          attack: 0.006,
          release: 0.18,
          peak: Math.min(0.85, 0.35 + burst * 0.18),
          sustain: 0.2
        });
        if (!env) return;
        const { ctx: c, gain, start, stop } = env;
        const osc = c.createOscillator();
        osc.type = "triangle";
        osc.frequency.setValueAtTime(780, start);
        osc.frequency.exponentialRampToValueAtTime(420, start + 0.16);
        osc.connect(gain);
        osc.start(start);
        osc.stop(stop);
      }

      function playBreak() {
        const env = createEnv(0.4, { attack: 0.004, release: 0.28, peak: 0.7, sustain: 0.15 });
        if (!env) return;
        const { ctx: c, gain, start, stop } = env;
        const noiseBuf = ensureNoiseBuffer(0.5);
        if (noiseBuf) {
          const noise = c.createBufferSource();
          noise.buffer = noiseBuf;
          const filter = c.createBiquadFilter();
          filter.type = "bandpass";
          filter.frequency.setValueAtTime(280, start);
          filter.Q.setValueAtTime(0.9, start);
          noise.connect(filter);
          filter.connect(gain);
          noise.start(start);
          noise.stop(stop);
        }
        const tone = c.createOscillator();
        tone.type = "sawtooth";
        tone.frequency.setValueAtTime(220, start);
        tone.frequency.exponentialRampToValueAtTime(120, stop);
        tone.connect(gain);
        tone.start(start);
        tone.stop(stop);
      }

      function playStart() {
        const env = createEnv(0.9, { attack: 0.02, release: 0.6, peak: 0.5, sustain: 0.25 });
        if (!env) return;
        const { ctx: c, gain, start, stop } = env;
        const noiseBuf = ensureNoiseBuffer(1.0);
        if (noiseBuf) {
          const noise = c.createBufferSource();
          noise.buffer = noiseBuf;
          const filter = c.createBiquadFilter();
          filter.type = "highpass";
          filter.frequency.setValueAtTime(160, start);
          filter.frequency.exponentialRampToValueAtTime(980, start + 0.4);
          filter.Q.setValueAtTime(0.7, start);
          noise.connect(filter);
          filter.connect(gain);
          noise.start(start);
          noise.stop(stop);
        }
        const tone = c.createOscillator();
        tone.type = "sine";
        tone.frequency.setValueAtTime(220, start);
        tone.frequency.exponentialRampToValueAtTime(620, start + 0.5);
        tone.frequency.linearRampToValueAtTime(440, stop);
        tone.connect(gain);
        tone.start(start);
        tone.stop(stop);
      }

      async function resume() {
        const c = ensureCtx();
        if (!c) return;
        if (c.state === "suspended") {
          try { await c.resume(); } catch (err) { /* ignore */ }
        }
      }

      return { playFire, playBreak, playStart, resume };
    })();

    window.addEventListener("pointerdown", () => { audio.resume(); }, { passive: true });

    // ë°”ë‹¥ í…ìŠ¤ì²˜(ìº”ë²„ìŠ¤ë¡œ ìƒì„±í•˜ëŠ” ê·¸ë¦¬ë“œ/í™œì£¼ë¡œ ë¼ì¸)
    function createRunwayTexture() {
      const c = document.createElement('canvas');
      c.width = 512; c.height = 512;
      const g = c.getContext('2d');
      // ë°°ê²½
      g.fillStyle = '#0a1f2a';
      g.fillRect(0, 0, c.width, c.height);
      // ë¯¸ì„¸ ë…¸ì´ì¦ˆ ì 
      g.globalAlpha = 0.06;
      for (let i = 0; i < 1200; i++) {
        const x = Math.random() * c.width;
        const y = Math.random() * c.height;
        const s = Math.random() * 1.6;
        g.fillStyle = '#103244';
        g.fillRect(x, y, s, s);
      }
      g.globalAlpha = 1.0;
      // ì„¸ë¡œ ê·¸ë¦¬ë“œ ë¼ì¸
      g.strokeStyle = '#1a6c8f';
      g.lineWidth = 3;
      for (let x = 0; x <= c.width; x += 64) {
        g.beginPath(); g.moveTo(x + 0.5, 0); g.lineTo(x + 0.5, c.height); g.stroke();
      }
      // ê°€ë¡œ ìŠ¤íŠ¸ë¦½(í™œì£¼ë¡œ í‘œì‹)
      for (let y = 40; y < c.height; y += 96) {
        g.fillStyle = '#2a9fd0';
        g.globalAlpha = 0.42;
        g.fillRect(0, y, c.width, 14);
        g.globalAlpha = 1.0;
        // ê°€ìš´ë° ì–‡ì€ ë¼ì¸ ê°•ì¡°
        g.fillStyle = '#66d3ff';
        g.fillRect(0, y + 5, c.width, 3);
      }
      // ì¤‘ì•™ ë ˆì¸ ë¼ì¸(ì ì„ )
      g.fillStyle = '#8fe6ff';
      for (let y = 0; y < c.height; y += 48) {
        g.fillRect(c.width/2 - 5, y + 8, 10, 20);
      }
      const tex = new THREE.CanvasTexture(c);
      if (THREE.SRGBColorSpace) tex.colorSpace = THREE.SRGBColorSpace;
      tex.needsUpdate = true;
      return tex;
    }

    // ----- í”Œë ˆì´ì–´ -----
    const playerSize = new THREE.Vector3(2.2, 2.2, 2.2);
    const playerMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      metalness: 0.22,
      roughness: 0.32,
      emissive: 0x1b1f36,
      emissiveIntensity: 0.12
    });
    const player = new THREE.Group();
    // ì½”(ë…¸ì¦ˆ)
    const nose = new THREE.Mesh(new THREE.ConeGeometry(1.0, 2.2, 10), playerMat);
    nose.rotation.x = -Math.PI / 2; // -z ë°©í–¥(ë‚˜ê°€ëŠ” ë°©í–¥)ìœ¼ë¡œ í–¥í•˜ë„ë¡
    nose.position.set(0, 0, -0.25);
    nose.castShadow = true;
    // ëª¸ì²´
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.95, 1.6, 8), playerMat);
    body.rotation.x = -Math.PI / 2;
    body.position.set(0, 0, 0.7);
    body.castShadow = true;
    // ë‚ ê°œ (ì¢Œìš°ê°€ ëìœ¼ë¡œ ê°ˆìˆ˜ë¡ ì¢ì•„ì§€ëŠ” íŠ¸ë¼í˜ì¡°ì´ë“œ í˜•íƒœ)
    const wingMat = new THREE.MeshStandardMaterial({
      color: 0xe5ecff,
      metalness: 0.18,
      roughness: 0.42,
      emissive: 0x171c2d,
      emissiveIntensity: 0.08
    });
    function makeTaperedWing(side = 1) {
      // side: +1 ì˜¤ë¥¸ìª½, -1 ì™¼ìª½
      const geo = new THREE.BoxGeometry(1.2, 0.14, 1.3); // ë” ë„“ê³  ë‘êº¼ìš´ ë‚ ê°œ (ì½©ì½”ë“œ ëŠë‚Œ)
      const pos = geo.attributes.position;
      pos.needsUpdate = true;
      // x ê¸°ì¤€ìœ¼ë¡œ ëìœ¼ë¡œ ê°ˆìˆ˜ë¡ z(ì½”ë“œ ê¸¸ì´)ë¥¼ ì¤„ì—¬ ë‚ ê°œ ëì´ ì¢ì•„ì§€ëŠ” ëŠë‚Œ
      // root(ê¸°ì²´ ìª½) ë³´ì¡´, tip(ë)ì—ì„œ 0.6ë°°ë¡œ ì¶•ì†Œ
      const v = new THREE.Vector3();
      let minX = Infinity, maxX = -Infinity;
      for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);
        minX = Math.min(minX, v.x);
        maxX = Math.max(maxX, v.x);
      }
      for (let i = 0; i < pos.count; i++) {
        v.fromBufferAttribute(pos, i);
        const t = (side > 0)
          ? (v.x - minX) / (maxX - minX) // ì˜¤ë¥¸ìª½ ë‚ ê°œëŠ” +xê°€ tip
          : (maxX - v.x) / (maxX - minX); // ì™¼ìª½ ë‚ ê°œëŠ” -xê°€ tip
        const factor = 1.0 - 0.8 * Math.max(0, Math.min(1, t)); // 1.0 -> 0.6ë¡œ ì„ í˜• ì¶•ì†Œ
        v.z *= factor;
        pos.setXYZ(i, v.x, v.y, v.z);
      }
      geo.computeVertexNormals();
      const mesh = new THREE.Mesh(geo, wingMat);
      mesh.castShadow = true;
      // ìŠ¤ìœ•ë°± ê°ë„ë¥¼ ì•½ê°„ ì™„í™”í•˜ê³ , ëª¸í†µì— ë°€ì°©ë˜ë„ë¡ ìœ„ì¹˜ ì¡°ì •
      mesh.rotation.y = side * -0.08;
      mesh.position.set(side * 1.2, 0, 0.65);
      return mesh;
    }
    const leftWing = makeTaperedWing(-1);
    const rightWing = makeTaperedWing(1);
    // ì—”ì§„ ê¸€ë¡œìš° (ë”°ëœ»í•œ ë¶‰ì€ë¹›)
    const engineMat = new THREE.MeshStandardMaterial({ color: 0xffb3a1, emissive: 0xff5a3d, emissiveIntensity: 1.0 });
    const engine = new THREE.Mesh(new THREE.SphereGeometry(0.22, 10, 10), engineMat);
    engine.position.set(0, 0, 1.5);
    // ì—”ì§„ ë¶ˆê½ƒ(ì• ë‹ˆë©”ì´ì…˜) - ë” í¬ê³  ë¶‰ì€ ìƒ‰ê°
    const flameMat = new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0xff3333, emissiveIntensity: 1.35, transparent: true, opacity: 0.9 });
    const flame = new THREE.Mesh(new THREE.ConeGeometry(0.55, 1.8, 12), flameMat);
    flame.rotation.x = Math.PI / 2; // +z(í›„ë°©)ìœ¼ë¡œ ë»—ëŠ” ë¶ˆê½ƒ
    flame.position.set(0, 0, 2.2);
    flame.castShadow = false;
    player.add(nose, body, leftWing, rightWing, engine, flame);
    player.userData.flame = flame;
    // ë¹„í–‰ ê³ ë„ ì•½ê°„ ë‚®ì¶¤
    player.position.set(0, 1.6, 0);
    scene.add(player);

    // ë°”ë‹¥(í™œì£¼ë¡œ í…ìŠ¤ì²˜ + ìŠ¤í¬ë¡¤)
    const runwayTex = createRunwayTexture();
    runwayTex.wrapS = THREE.RepeatWrapping;
    runwayTex.wrapT = THREE.RepeatWrapping;
    runwayTex.repeat.set(2, 10);
    runwayTex.anisotropy = 4;
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(24, 1000),
      new THREE.MeshBasicMaterial({ color: 0xffffff, map: runwayTex })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.z = -300;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // ----- ì  ë¸”ë¡ í’€ -----
    const ENEMY_POOL_SIZE = 50;
    const enemyGeo = new THREE.BoxGeometry(2.2, 2.2, 2.2);
    const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff8fa3, metalness: 0.25, roughness: 0.45, emissive: 0x3c0a0f, emissiveIntensity: 0.35 });
    const enemies = [];
    for (let i = 0; i < ENEMY_POOL_SIZE; i++) {
      const m = new THREE.Mesh(enemyGeo, enemyMat.clone()); // ê°œë³„ ìƒ‰ìƒ ë³€ê²½ ê°€ëŠ¥í•˜ë„ë¡ clone
      m.castShadow = true;
      m.visible = false;
      m.position.set(0, 2.5, -200);
      scene.add(m);
      enemies.push(m);
    }

    // ìŠ¤í° ë ˆì¸(ì¢Œí‘œ)
    const LANES = [-6, -3, 0, 3, 6];

    // ì  ìœ í˜• ì •ì˜(5ì¢…): ì²´ë ¥, í¬ê¸°, ì¬ì§ˆ ì°¨ì´ë¡œ ë‹¤ì–‘í™”
    const ENEMY_TYPES = [
      { hp: 2, scale: 1.0, color: 0xff7699, emissive: 0x6c1230, emissiveIntensity: 0.5, score: 14 },
      { hp: 4, scale: 1.5, color: 0xff9a5b, emissive: 0x6a2a05, emissiveIntensity: 0.45, score: 18 },
      { hp: 6, scale: 2.0, color: 0xffd360, emissive: 0x5f2f00, emissiveIntensity: 0.4, score: 24 },
      { hp: 8, scale: 2.5, color: 0x92d2ff, emissive: 0x0b3460, emissiveIntensity: 0.48, score: 30 },
      { hp: 10, scale: 3.0, color: 0xc1a6ff, emissive: 0x2d0f6f, emissiveIntensity: 0.52, score: 38 }
    ];

    function applyEnemyType(mesh, def) {
      const heightMul = def.scale * (0.9 + Math.random() * 0.7);
      mesh.scale.set(def.scale, heightMul, def.scale);
      mesh.material.color.setHex(def.color);
      mesh.material.emissive.setHex(def.emissive);
      mesh.material.emissiveIntensity = def.emissiveIntensity;
      mesh.userData.maxHp = def.hp;
      mesh.userData.hp = def.hp;
      mesh.userData.type = def;
      mesh.userData.damagePhase = 0;
      mesh.userData.hitbox = new THREE.Vector3(2.2 * def.scale, 2.2 * heightMul, 2.2 * def.scale);
      mesh.userData.killScore = def.score;
    }

    function updateEnemyDamageVisual(mesh) {
      const ratio = Math.max(0, mesh.userData.hp / mesh.userData.maxHp);
      const base = mesh.userData.type;
      const intensity = base.emissiveIntensity + (1 - ratio) * 0.35;
      mesh.material.emissiveIntensity = intensity;
      mesh.userData.damagePhase = 4; // ì§§ì€ íƒ€ê²© í›„ê´‘ì„ ìœ„í•´ í”Œë˜ê·¸
    }

    // ë¸”ë¡ íŒŒí¸ ì´í™íŠ¸ í’€
    const DEBRIS_POOL_SIZE = 120;
    const debrisGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
    const debrisPieces = [];
    for (let i = 0; i < DEBRIS_POOL_SIZE; i++) {
      const mat = new THREE.MeshStandardMaterial({
        color: 0xffaaaa,
        metalness: 0.15,
        roughness: 0.65,
        emissive: 0x000000,
        transparent: true,
        opacity: 0
      });
      const chunk = new THREE.Mesh(debrisGeo, mat);
      chunk.visible = false;
      chunk.castShadow = true;
      chunk.userData = {
        velocity: new THREE.Vector3(),
        spin: new THREE.Vector3(),
        life: 0,
        maxLife: 900
      };
      scene.add(chunk);
      debrisPieces.push(chunk);
    }

    function spawnDebrisBurst(position, typeDef) {
      let spawned = 0;
      for (const chunk of debrisPieces) {
        if (chunk.visible) continue;
        chunk.visible = true;
        chunk.position.copy(position);
        chunk.position.x += (Math.random() - 0.5) * 1.2;
        chunk.position.y += (Math.random() - 0.5) * 1.0;
        chunk.position.z += (Math.random() - 0.5) * 1.2;
        chunk.material.color.setHex(typeDef.color);
        chunk.material.opacity = 0.95;
        chunk.userData.velocity.set(
          (Math.random() - 0.5) * 0.3,
          Math.random() * 0.4 + 0.18,
          (Math.random() - 0.5) * 0.4
        );
        chunk.userData.spin.set(
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2
        );
        chunk.userData.life = 0;
        chunk.userData.maxLife = 900 + Math.random() * 400;
        if (++spawned >= 12) break; // í•œ ë²ˆì— 12ì¡°ê°ê¹Œì§€ë§Œ ì‚¬ìš©
      }
    }

    // ë¯¸ì‚¬ì¼ ì•„ì´í…œ
    const itemGeo = new THREE.OctahedronGeometry(1.0, 0);
    const itemMat = new THREE.MeshStandardMaterial({ 
      color: 0x4dffb8, 
      emissive: 0x00cc77, 
      emissiveIntensity: 1.2, 
      metalness: 0.2, 
      roughness: 0.3 
    });
    const MISSILE_ITEM_POOL_SIZE = 40;
    const missileItems = [];
    const missileItemSize = new THREE.Vector3(1.4, 1.4, 1.4);
    const MISSILE_ITEM_SPAWN_CHANCE = 0.1; // ì  ìƒì„± ì‹œ ì•„ì´í…œì´ ë‚˜ì˜¬ í™•ë¥ 
    function resetMissileItem(item) {
      item.visible = false;
      item.position.set(0, item.userData.originalY, -200);
      item.userData.bobOffset = 0;
    }

    for (let i = 0; i < MISSILE_ITEM_POOL_SIZE; i++) {
      const mesh = new THREE.Mesh(itemGeo, itemMat.clone());
      mesh.castShadow = true;
      // ê° ì•„ì´í…œì— ë³„ë„ ì• ë‹ˆë©”ì´ì…˜ ì†ë„ë¥¼ ì €ì¥í•´ë‘ê³  í’€ë§í•œë‹¤.
      mesh.userData = {
        rotationSpeed: 0,
        bobOffset: 0,
        bobSpeed: 0,
        originalY: 2.5
      };
      resetMissileItem(mesh);
      scene.add(mesh);
      missileItems.push(mesh);
    }

    function spawnMissileItem(x, z) {
      const item = missileItems.find(o => !o.visible);
      if (!item) return;
      // ì„ íƒëœ ì•„ì´í…œì„ í•´ë‹¹ ë ˆì¸ ìœ„ì¹˜ì— ì¬ë°°ì¹˜í•˜ê³  ì• ë‹ˆë©”ì´ì…˜ íŒŒë¼ë¯¸í„°ë¥¼ ê°±ì‹ í•œë‹¤.
      item.visible = true;
      item.position.set(x, item.userData.originalY, z);
      item.rotation.set(0, Math.random() * Math.PI * 2, 0);
      item.userData.rotationSpeed = 0.012 + Math.random() * 0.015;
      item.userData.bobOffset = Math.random() * Math.PI * 2;
      item.userData.bobSpeed = 0.02 + Math.random() * 0.015;
    }

    // ----- ìƒíƒœ -----
    let isRunning = false;
    let isDead = false;
    let score = 0;
    let best = Number(localStorage.getItem("space_dodge_best") || 0);
    let baseSpeed = 0.6;      // ì ì˜ ê¸°ë³¸ ì „ì§„ ì†ë„
    let speedScale = 1.0;     // ì‹œê°„ ê²½ê³¼ì— ë”°ë¼ ì¦ê°€
    let spawnEvery = 550;     // ì  ìƒì„± ê°„ê²©(ms) - ê°ì†Œ ë¹ˆë„ ë‚®ì¶¤
    let lastSpawn = 0;
    let lastTime = performance.now();
    // í”Œë ˆì´ì–´ ê¸°ìš¸ê¸°(ë¡¤) ìƒíƒœ
    let playerRoll = 0;       // zì¶• íšŒì „(ì¢Œìš° ê¸°ìš¸ê¸°)
    let missilesPerShot = 1;
    let missilesCollected = 0;
    const MISSILE_SPREAD = 0.85; // ë™ì‹œì— ë°œì‚¬ë  ë•Œ ì¢Œìš° ê°„ê²©
   // ì´ì•Œ(ë¯¸ì‚¬ì¼) í’€
    const BULLET_POOL_SIZE = 120;
    const bulletGeo = new THREE.CylinderGeometry(0.22, 0.32, 1.45, 8);
    const bulletMat = new THREE.MeshStandardMaterial({ color: 0x9be8ff, emissive: 0x66ccff, emissiveIntensity: 1.8, metalness: 0.1, roughness: 0.3 });
    const bullets = [];
    for (let i = 0; i < BULLET_POOL_SIZE; i++) {
      const b = new THREE.Mesh(bulletGeo, bulletMat);
      b.rotation.x = -Math.PI / 2; // -Zë¡œ ë‚ ì•„ê°€ë„ë¡
      b.visible = false;
      b.userData.vz = -1.6; // ê¸°ë³¸ ì†ë„ (ì „ë°© ë°©í–¥)
      // ê¸€ë¡œìš°(ë°œê´‘) ì´í™íŠ¸: ì•½ê°„ í° ì‹¤ë¦°ë”ë¥¼ ìì‹ìœ¼ë¡œ ë¶™ì—¬ ê°€ì‚°í•©ì„±
      const glowGeo = new THREE.CylinderGeometry(0.34, 0.46, 1.68, 8);
      const glowMat = new THREE.MeshBasicMaterial({ color: 0x9be8ff, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      // ë¶€ëª¨(bullet)ê°€ ì´ë¯¸ -Math.PI/2 íšŒì „ë˜ì–´ ìˆì–´ ìì‹ì€ ì¶”ê°€ íšŒì „ ë¶ˆí•„ìš”
      glow.rotation.x = 0;
      b.add(glow);
      scene.add(b);
      bullets.push(b);
    }
    const bulletSize = new THREE.Vector3(0.48, 0.48, 1.45);
    const enemyHitbox = new THREE.Vector3();
    let fireCooldown = 0;
    const BASE_MISSILE_FIRE_INTERVAL = 150; // ms
    let missileFireInterval = BASE_MISSILE_FIRE_INTERVAL;
    window.gameConfig = Object.assign(window.gameConfig || {}, {
      getMissileFireInterval: () => missileFireInterval,
      setMissileFireInterval: (ms) => {
        const next = Number(ms);
        if (!Number.isFinite(next) || next <= 0) return missileFireInterval;
        missileFireInterval = Math.max(40, next);
        return missileFireInterval;
      }
    });
    // ì¹´ë©”ë¼ ì œì–´ ìƒíƒœ
    let camYaw = 0.0;           // ì¢Œìš° íšŒì „ (ë¼ë””ì•ˆ)
    let camPitch = 0.28;        // ìƒí•˜ (ë¼ë””ì•ˆ, ìœ„ë¡œ ì–‘ìˆ˜)
    let camDist = 19;           // í”Œë ˆì´ì–´ë¡œë¶€í„° ê±°ë¦¬
    const camMinDist = 10;
    const camMaxDist = 32;
    const camTargetOffset = new THREE.Vector3(0, 1.8, 0); // í”Œë ˆì´ì–´ ìœ„ë¥¼ ë³´ë„ë¡

    // HUD DOM
    const $score = document.getElementById("score");
    const $best = document.getElementById("best");
    const $speed = document.getElementById("speed");
    const $missiles = document.getElementById("missiles");
    const $missilesCollected = document.getElementById("missilesCollected");
    const $center = document.getElementById("centerMsg");
    $best.textContent = best.toString();
    showCenter(true);
    updateHUD();

    // ----- ì…ë ¥ -----
    const input = { left: false, right: false };
    let autoFireEnabled = false;
    let fireHeld = false;
    window.addEventListener("keydown", (e) => {
      audio.resume();
      // Shift + ë°©í–¥í‚¤ => ì¹´ë©”ë¼ ì¡°ì •
      if (e.shiftKey) {
        if (e.code === "ArrowLeft") { camYaw -= 0.08; e.preventDefault(); return; }
        if (e.code === "ArrowRight") { camYaw += 0.08; e.preventDefault(); return; }
        if (e.code === "ArrowUp") { camPitch = Math.min(1.2, camPitch + 0.06); e.preventDefault(); return; }
        if (e.code === "ArrowDown") { camPitch = Math.max(-0.05, camPitch - 0.06); e.preventDefault(); return; }
      }
      if (e.code === "ArrowLeft" || e.code === "KeyA") input.left = true;
      if (e.code === "ArrowRight" || e.code === "KeyD") input.right = true;
      if (e.code === "KeyF") { // ë°œì‚¬
        e.preventDefault();
        fireHeld = true;
        tryFire();
        return;
      }
      if (e.code === "Space") {
        e.preventDefault();
        toggleRun();
      }
      if (e.code === "KeyR") restart();
    });
    window.addEventListener("keyup", (e) => {
      if (e.code === "ArrowLeft" || e.code === "KeyA") input.left = false;
      if (e.code === "ArrowRight" || e.code === "KeyD") input.right = false;
      if (e.code === "KeyF") fireHeld = false;
    });

    // í„°ì¹˜ë¡œ ì¢Œìš° ì´ë™: í„°ì¹˜í•œ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë“œë˜ê·¸ ë°©í–¥ì— ë”°ë¼ ì´ë™
    // - ì²˜ìŒ í„°ì¹˜í•œ ì§€ì ì—ì„œ ì™¼ìª½ìœ¼ë¡œ ë“œë˜ê·¸: ì™¼ìª½ìœ¼ë¡œ ì´ë™
    // - ì²˜ìŒ í„°ì¹˜í•œ ì§€ì ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë“œë˜ê·¸: ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™
    // - í„°ì¹˜ í•´ì œ: ì •ì§€
    let activeTouchId = null;
    let initialTouchX = null;
    const MOVE_THRESHOLD = 10; // í”½ì…€ ë‹¨ìœ„ì˜ ì´ë™ ì„ê³„ê°’

    function updateMovementFromTouch(currentX) {
      if (initialTouchX === null) return;
      
      const dx = currentX - initialTouchX;
      if (dx > MOVE_THRESHOLD) {
        // ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë“œë˜ê·¸ ì¤‘: ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™
        input.left = false;
        input.right = true;
      } else if (dx < -MOVE_THRESHOLD) {
        // ì™¼ìª½ìœ¼ë¡œ ë“œë˜ê·¸ ì¤‘: ì™¼ìª½ìœ¼ë¡œ ì´ë™
        input.left = true;
        input.right = false;
      } else {
        // ì„ê³„ê°’ ë‚´ì—ì„œëŠ” ì •ì§€
        input.left = false;
        input.right = false;
      }
    }

    window.addEventListener("touchstart", (e) => {
      audio.resume();
      // ì»¨íŠ¸ë¡¤ ë²„íŠ¼ì´ë‚˜ HUDë¥¼ í„°ì¹˜í•œ ê²½ìš°ëŠ” ë¬´ì‹œ
      if (e.target && (e.target.closest && (e.target.closest('.control-bar') || e.target.closest('#hud') || e.target.closest('#hint')))) return;

      if (e.touches && e.touches.length > 0) {
        const touch = e.touches[0];
        activeTouchId = touch.identifier;
        initialTouchX = touch.clientX;
        // ì´ˆê¸° í„°ì¹˜ ì‹œì—ëŠ” ì´ë™í•˜ì§€ ì•ŠìŒ
        input.left = false;
        input.right = false;
      }
      e.preventDefault();
    }, { passive: false });

    window.addEventListener("touchmove", (e) => {
      // ì»¨íŠ¸ë¡¤ ë²„íŠ¼ì´ë‚˜ HUDë¥¼ í„°ì¹˜í•œ ê²½ìš°ëŠ” ë¬´ì‹œ
      if (e.target && (e.target.closest && (e.target.closest('.control-bar') || e.target.closest('#hud') || e.target.closest('#hint')))) return;
      
      // í˜„ì¬ í™œì„±í™”ëœ í„°ì¹˜ ì°¾ê¸°
      let touch = null;
      for (let i = 0; i < e.touches.length; i++) {
        if (e.touches[i].identifier === activeTouchId) {
          touch = e.touches[i];
          break;
        }
      }
      
      // í™œì„±í™”ëœ í„°ì¹˜ê°€ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ í„°ì¹˜ ì‚¬ìš©
      if (!touch) touch = e.touches[0];
      
      // í˜„ì¬ í„°ì¹˜ ìœ„ì¹˜ì— ë”°ë¼ ì´ë™ ë°©í–¥ ì—…ë°ì´íŠ¸
      updateMovementFromTouch(touch.clientX);
      
      e.preventDefault();
    }, { passive: false });
    
    function clearTouchMovement() {
      input.left = false;
      input.right = false;
      activeTouchId = null;
      initialTouchX = null;
    }
    window.addEventListener("touchend", (e) => { clearTouchMovement(); }, { passive: true });
    window.addEventListener("touchcancel", (e) => { clearTouchMovement(); }, { passive: true });

    // ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ë¡œ ì¹´ë©”ë¼ íšŒì „
    const mouse = { dragging: false, lastX: 0, lastY: 0 };
    window.addEventListener("mousedown", (e) => {
      mouse.dragging = true; mouse.lastX = e.clientX; mouse.lastY = e.clientY; e.preventDefault();
    });
    window.addEventListener("mousemove", (e) => {
      if (!mouse.dragging) return;
      const dx = e.clientX - mouse.lastX;
      const dy = e.clientY - mouse.lastY;
      mouse.lastX = e.clientX; mouse.lastY = e.clientY;
      camYaw += dx * 0.005;
      camPitch = Math.max(-0.05, Math.min(1.2, camPitch - dy * 0.003));
    });
    window.addEventListener("mouseup", () => { mouse.dragging = false; });
    window.addEventListener("mouseleave", () => { mouse.dragging = false; });
    // íœ ë¡œ ì¤Œ
    window.addEventListener("wheel", (e) => {
      e.preventDefault();
      camDist = Math.max(camMinDist, Math.min(camMaxDist, camDist + Math.sign(e.deltaY) * 1.2));
    }, { passive: false });

    // ì˜¤í†  ë°œì‚¬ í† ê¸€ ë²„íŠ¼
    const $autoFireBtn = document.getElementById("autoFireBtn");
    function updateAutoFireBtn() {
      $autoFireBtn.classList.toggle("active", autoFireEnabled);
      $autoFireBtn.textContent = 'AUTO';
      $autoFireBtn.setAttribute('aria-pressed', String(autoFireEnabled));
    }
    $autoFireBtn.addEventListener("click", () => {
      autoFireEnabled = !autoFireEnabled;
      updateAutoFireBtn();
    });
    updateAutoFireBtn();

    // í•˜ë‹¨ ì‹œì•¼ ì¡°ì‘ ë²„íŠ¼ ë¡œì§ (ëˆ„ë¥¼ ë•Œë§ˆë‹¤ ì¡°ê¸ˆì”© ì´ë™, ê¸¸ê²Œ ëˆ„ë¥´ë©´ ë°˜ë³µ)
    const btnUp = document.getElementById('viewUp');
    const btnDown = document.getElementById('viewDown');
    const btnLeft = document.getElementById('viewLeft');
    const btnRight = document.getElementById('viewRight');
    const btnOut = document.getElementById('viewOut');
    const btnIn = document.getElementById('viewIn');
    const btnOrigin = document.getElementById('viewOrigin');
    const STEP = { yaw: 0.06, pitch: 0.05, dist: 1.2 };
    function clampPitch(v) { return Math.max(-0.05, Math.min(1.2, v)); }
    function clampDist(v) { return Math.max(camMinDist, Math.min(camMaxDist, v)); }
    function nudge(action) {
      switch (action) {
        case 'up':    camPitch = clampPitch(camPitch + STEP.pitch); break;
        case 'down':  camPitch = clampPitch(camPitch - STEP.pitch); break;
        case 'left':  camYaw -= STEP.yaw; break;
        case 'right': camYaw += STEP.yaw; break;
        case 'out':   camDist = clampDist(camDist + STEP.dist); break;
        case 'in':    camDist = clampDist(camDist - STEP.dist); break;
        case 'origin': camYaw = 0; camPitch = 0.28; camDist = 19; break;
      }
    }
    function bindNudge(btn, action) {
      let timer;
      const start = (e) => {
        e.stopPropagation();
        nudge(action);
        clearInterval(timer);
        timer = setInterval(() => nudge(action), 100);
      };
      const stop = () => { clearInterval(timer); };
      btn.addEventListener('click', (e) => { e.stopPropagation(); nudge(action); });
      btn.addEventListener('mousedown', start);
      btn.addEventListener('mouseup', stop);
      btn.addEventListener('mouseleave', stop);
      btn.addEventListener('touchstart', start, { passive: true });
      btn.addEventListener('touchend', stop, { passive: true });
      btn.addEventListener('touchcancel', stop);
    }
    bindNudge(btnUp, 'up');
    bindNudge(btnDown, 'down');
    bindNudge(btnLeft, 'left');
    bindNudge(btnRight, 'right');
    bindNudge(btnOut, 'out');
    bindNudge(btnIn, 'in');
    bindNudge(btnOrigin, 'origin');
    // ì‹œì‘/ì •ì§€ ë²„íŠ¼
    const $startBtn = document.getElementById('startBtn');
    const $pauseBtn = document.getElementById('pauseBtn');
    $startBtn.addEventListener('click', async () => {
      if (isDead) restart();
      isRunning = true;
      showCenter(false);
      // Try entering fullscreen on first user gesture (mobile policy)
      if (!isFullscreen()) {
        await enterFullscreen();
        if (screen.orientation && screen.orientation.lock) {
          try { await screen.orientation.lock('landscape'); } catch (e) { /* ignore */ }
        }
      }
    });
    $pauseBtn.addEventListener('click', () => {
      if (isDead) return;
      isRunning = false;
      showCenter(true, 'ì¼ì‹œì •ì§€', 'ì‹œì‘ ë²„íŠ¼ìœ¼ë¡œ ì¬ê°œ');
    });

    // ì „ì²´ í™”ë©´ í† ê¸€
    const $fsBtn = document.getElementById('fsBtn');
    function isNativeFullscreen() {
      return document.fullscreenElement || document.webkitFullscreenElement;
    }
    function isPseudoFullscreen() {
      return document.body.classList.contains('pseudo-fullscreen');
    }
    function isFullscreen() { return !!(isNativeFullscreen() || isPseudoFullscreen()); }
    function updateFsBtn() {
      if (!$fsBtn) return;
      const on = !!isFullscreen();
      $fsBtn.textContent = on ? ' ğŸ—— ' : ' â›¶ ';
      $fsBtn.setAttribute('aria-pressed', String(on));
    }
    async function enterFullscreen() {
      const el = document.documentElement; // í˜ì´ì§€ ì „ì²´
      try {
        if (el.requestFullscreen) { await el.requestFullscreen(); }
        else if (el.webkitRequestFullscreen) { await el.webkitRequestFullscreen(); }
        else if (document.body.requestFullscreen) { await document.body.requestFullscreen(); }
        else {
          // Fallback: pseudo-fullscreen
          document.body.classList.add('pseudo-fullscreen');
        }
      } catch (e) {
        // Fallback on error
        document.body.classList.add('pseudo-fullscreen');
      }
      updateFsBtn();
    }
    async function exitFullscreen() {
      try {
        if (document.exitFullscreen) { await document.exitFullscreen(); }
        else if (document.webkitExitFullscreen) { await document.webkitExitFullscreen(); }
      } catch (e) { /* ignore */ }
      // Always clear pseudo mode
      document.body.classList.remove('pseudo-fullscreen');
      updateFsBtn();
    }
    if ($fsBtn) {
      $fsBtn.addEventListener('click', () => {
        if (isFullscreen()) exitFullscreen(); else enterFullscreen();
      });
      document.addEventListener('fullscreenchange', updateFsBtn);
      document.addEventListener('webkitfullscreenchange', updateFsBtn);
      updateFsBtn();
    }

    function toggleRun() {
      if (isDead) return;
      const next = !isRunning;
      isRunning = next;
      showCenter(!isRunning);
      if (next) audio.playStart();
    }

    function showCenter(show, title, desc) {
      if (show) {
        if (title) {
          $center.querySelector("h1").textContent = title;
        }
        if (desc) {
          $center.querySelectorAll("p")[0].textContent = desc;
        }
        $center.style.display = "flex";
      } else {
        $center.style.display = "none";
      }
    }

    function restart() {
      // ì´ˆê¸°í™”
      isDead = false;
      isRunning = false;
      score = 0;
      speedScale = 1.0;
      baseSpeed = 0.6;
      spawnEvery = 550; // ì¬ì‹œì‘ ì‹œì—ë„ ì—¬ìœ  ìˆê²Œ ì‹œì‘
      $score.textContent = "0";
      $speed.textContent = speedScale.toFixed(1) + "x";
      // ì  ë¦¬ì…‹
      for (const e of enemies) {
        e.visible = false;
        e.position.z = -200;
        e.userData.hp = 0;
      }
      // ì´ì•Œ ë¦¬ì…‹
      for (const b of bullets) {
        b.visible = false;
        b.position.z = 0;
      }
      for (const item of missileItems) {
        // ì¬ì‹œì‘ ì‹œì—ëŠ” ëª¨ë“  ì•„ì´í…œì„ ë¹„í™œì„±í™”í•˜ê³  ì˜¤í”„ìŠ¤í¬ë¦°ì— ìˆ¨ê¸´ë‹¤.
        resetMissileItem(item);
      }
      for (const chunk of debrisPieces) {
        chunk.visible = false;
        chunk.material.opacity = 0;
        chunk.userData.life = 0;
      }
      fireCooldown = 0;
      missilesPerShot = 1;
      missilesCollected = 0;
      fireHeld = false;
      updateHUD();
      // í”Œë ˆì´ì–´ ìœ„ì¹˜
      player.position.x = 0;
      // ë¡¤ ì´ˆê¸°í™”
      playerRoll = 0;
      player.rotation.z = 0;
      showCenter(true, "Space Dodge", "â†/â†’ ë˜ëŠ” A/Dë¡œ ì¢Œìš° ì´ë™");
    }

    // ----- ìœ í‹¸ -----
    function spawnEnemy() {
      const e = enemies.find(o => !o.visible);
      if (!e) return;
      e.visible = true;
      const laneX = LANES[Math.floor(Math.random() * LANES.length)];
      const type = ENEMY_TYPES[Math.floor(Math.random() * ENEMY_TYPES.length)];
      applyEnemyType(e, type);
      e.position.set(laneX, 2.5, -280 - Math.random() * 60);
      e.userData.passed = false;
      // ë¸”ë¡ì´ ìƒì„±ë  ë•Œ ì¼ì • í™•ë¥ ë¡œ ê°™ì€ ë ˆì¸ì— ì•„ì´í…œì„ ë¯¸ë¦¬ ë°°ì¹˜í•œë‹¤.
      // ì ì„ íŒŒê´´í•˜ì§€ ì•Šì•„ë„ í”Œë ˆì´ì–´ê°€ ì§€ë‚˜ê°€ë©° ì•„ì´í…œì„ ì¤ë„ë¡ ì „ë°©ì— ë„ì›Œë‘”ë‹¤.
      if (Math.random() < MISSILE_ITEM_SPAWN_CHANCE) {
        const itemZ = e.position.z - 16 - Math.random() * 14;
        spawnMissileItem(laneX, itemZ);
      }
    }

    // ë°œì‚¬ ìœ í‹¸
    function tryFire() {
      const nowT = performance.now();
      if (nowT - (tryFire.last || 0) < missileFireInterval || fireCooldown > 0) return;
      tryFire.last = nowT;
      fireCooldown = missileFireInterval;
      audio.playFire(missilesPerShot);

      const originX = player.position.x;
      const originY = player.position.y;
      const originZ = player.position.z;
      const vz = -2.2 - speedScale * 0.2;
      const half = (missilesPerShot - 1) * 0.5;

      for (let i = 0; i < missilesPerShot; i++) {
        const bullet = bullets.find(o => !o.visible);
        if (!bullet) break;
        bullet.visible = true;
        const offsetX = (i - half) * MISSILE_SPREAD;
        // ì¢Œìš°ë¡œ ê°„ê²©ì„ ë‘ê³  ë™ì‹œì— ë°œì‚¬ (ì¤‘ì•™ ê¸°ì¤€ ëŒ€ì¹­)
        bullet.position.set(originX + offsetX, originY, originZ - 1.3);
        bullet.userData.vz = vz;
      }
    }

    function aabbIntersect(aPos, aSize, bPos, bSize) {
      return Math.abs(aPos.x - bPos.x) * 2 < (aSize.x + bSize.x) &&
             Math.abs(aPos.y - bPos.y) * 2 < (aSize.y + bSize.y) &&
             Math.abs(aPos.z - bPos.z) * 2 < (aSize.z + bSize.z);
    }

    function updateHUD() {
      $score.textContent = Math.floor(score).toString();
      $speed.textContent = speedScale.toFixed(1) + "x";
      if ($missiles) $missiles.textContent = missilesPerShot.toString();
      if ($missilesCollected) $missilesCollected.textContent = missilesCollected.toString();
    }

    // ----- ë©”ì¸ ë£¨í”„ -----
    function tick(now) {
      const dt = Math.min(50, now - lastTime); // ms
      lastTime = now;
      const frameScale = dt / 16.67;
      const isActive = isRunning && !isDead;
      const travelSpeed = isActive ? (baseSpeed + speedScale * 0.4) * frameScale : 0;

      // ë³„ ì´ë™(ì¹´ë©”ë¼ ìª½ìœ¼ë¡œ)
      const starPos = stars.geometry.attributes.position;
      const depth = stars.userData.depth;
      for (let i = 0; i < starPos.count; i++) {
        const z = starPos.getZ(i) + (0.05 + speedScale * 0.02) * frameScale;
        if (z > 10) {
          starPos.setZ(i, -Math.random() * depth - 100);
          starPos.setX(i, (Math.random() - 0.5) * 200);
        } else {
          starPos.setZ(i, z);
        }
      }
      starPos.needsUpdate = true;

      // ì…ë ¥ì— ë”°ë¥¸ í”Œë ˆì´ì–´ ì¢Œìš° ì´ë™
      if (isActive) {
        const move = 0.02 * dt * 0.6 * (1 + (speedScale - 1) * 0.2);
        if (input.left)  player.position.x -= move;
        if (input.right) player.position.x += move;
        // ë ˆì¼ ë²”ìœ„ ì œí•œ
        player.position.x = Math.max(-7.5, Math.min(7.5, player.position.x));
      }

      // ì¢Œ/ìš° ì´ë™ ì…ë ¥ì— ë”°ë¥¸ ê¸°ì²´ ë¡¤ë§(ê¸°ìš¸ê¸°)
      {
        const maxRoll = 0.28; // ìµœëŒ€ ê¸°ìš¸ê¸°(ë¼ë””ì•ˆ)
        const dir = (input.left ? 1 : 0) + (input.right ? -1 : 0); // left:+1, right:-1
        const targetRoll = isActive ? maxRoll * dir : 0;
        // ë¶€ë“œëŸ½ê²Œ ë³´ê°„
        playerRoll += (targetRoll - playerRoll) * 0.12;
        player.rotation.z = playerRoll;
      }

      // ì‹œì•¼ ì¡°ì‘ì€ ë²„íŠ¼ í´ë¦­/í™€ë“œì— ì˜í•´ ë‹¨ê³„ì ìœ¼ë¡œ ë°˜ì˜ë¨

      // íŒ”ë¡œìš° ì¹´ë©”ë¼ í¬ì§€ì…”ë‹: í”Œë ˆì´ì–´ ê¸°ì¤€ìœ¼ë¡œ ê¶¤ë„ ë°°ì¹˜ í›„ í”Œë ˆì´ì–´ë¥¼ ë°”ë¼ë´„
      {
        const target = new THREE.Vector3().copy(player.position).add(camTargetOffset);
        const cosP = Math.cos(camPitch);
        const offsetX = Math.sin(camYaw) * cosP * camDist;
        const offsetY = Math.sin(camPitch) * camDist;
        const offsetZ = Math.cos(camYaw) * cosP * camDist;
        camera.position.set(target.x + offsetX, target.y + offsetY, target.z + offsetZ);
        camera.lookAt(target);
      }

      // ë°œì‚¬ ì¿¨ë‹¤ìš´ ê°ì†Œ
      if (fireCooldown > 0) fireCooldown = Math.max(0, fireCooldown - dt);

      // ì˜¤í†  ë°œì‚¬
      if (isActive && (autoFireEnabled || fireHeld)) {
        tryFire();
      }

      // ì´ì•Œ ì—…ë°ì´íŠ¸ ë° ì ê³¼ì˜ ì¶©ëŒ ì²˜ë¦¬
      if (isActive) {
        for (const b of bullets) {
          if (!b.visible) continue;
          b.position.z += b.userData.vz * frameScale;
          if (b.position.z < -280) { b.visible = false; continue; }
          // ì ê³¼ ì¶©ëŒ ì²´í¬
          for (const e of enemies) {
            if (!e.visible) continue;
            enemyHitbox.copy(e.userData.hitbox || enemyHitbox.set(2.2, 2.2 * e.scale.y, 2.2));
            if (aabbIntersect(b.position, bulletSize, e.position, enemyHitbox)) {
              // í”¼ê²© ì²˜ë¦¬
              b.visible = false;
              e.userData.hp = Math.max(0, (e.userData.hp || 1) - 1);
              if (e.userData.hp <= 0) {
                const burstPos = e.position.clone();
                e.visible = false;
                e.position.z = -200;
                score += e.userData.killScore || 10; // ìœ í˜•ë³„ íŒŒê´´ ë³´ìƒ
                spawnDebrisBurst(burstPos, e.userData.type || ENEMY_TYPES[0]);
                audio.playBreak();
              } else {
                score += 3; // í”¼ê²© ë³´ìƒ(ë¶€ë¶„ íƒ€ê²©)
                updateEnemyDamageVisual(e);
              }
              break;
            }
          }
        }
      }

      // ë¯¸ì‚¬ì¼ ì•„ì´í…œ ì—…ë°ì´íŠ¸ ë° í”Œë ˆì´ì–´ ì¶©ëŒ ì²˜ë¦¬
      if (isActive) {
        for (const item of missileItems) {
          if (!item.visible) continue;
          // ì²œì²œíˆ íšŒì „ì‹œí‚¤ë©°, ìœ„ì•„ë˜ë¡œ í”ë“¤ë¦¬ë„ë¡ ì˜¤í”„ì…‹ì„ ëˆ„ì í•œë‹¤.
          item.rotation.y += item.userData.rotationSpeed * frameScale;
          item.userData.bobOffset += item.userData.bobSpeed * frameScale;
          item.position.y = item.userData.originalY + Math.sin(item.userData.bobOffset) * 0.3;
          // ì•„ì´í…œë„ ì ê³¼ ê°™ì€ ì†ë„ë¡œ ì „ë°©ì—ì„œ í”Œë ˆì´ì–´ìª½ìœ¼ë¡œ ì´ë™í•œë‹¤.
          item.position.z += travelSpeed;

          if (aabbIntersect(player.position, playerSize, item.position, missileItemSize)) {
            // í”Œë ˆì´ì–´ê°€ íšë“í•˜ë©´ ì ìˆ˜ ë³´ìƒì„ ì£¼ê³  ê³§ë°”ë¡œ í’€ë¡œ ë˜ëŒë¦°ë‹¤.
            resetMissileItem(item);
            missilesPerShot += 1;
            missilesCollected += 1;
            score += 5;
            updateHUD();
            continue;
          }

          if (item.position.z > 40) {
            // í™”ë©´ì„ ì§€ë‚˜ì¹œ ì•„ì´í…œë„ í’€ì— ë°˜í™˜í•œë‹¤.
            resetMissileItem(item);
          }
        }
      }

      // íŒŒí¸ ì• ë‹ˆë©”ì´ì…˜
      for (const chunk of debrisPieces) {
        if (!chunk.visible) continue;
        const data = chunk.userData;
        data.life += dt;
        if (data.life >= data.maxLife) {
          chunk.visible = false;
          chunk.material.opacity = 0;
          continue;
        }
        const lifeRatio = data.life / data.maxLife;
        chunk.position.addScaledVector(data.velocity, frameScale);
        data.velocity.y -= 0.035 * frameScale;
        data.velocity.multiplyScalar(0.995);
        chunk.rotation.x += data.spin.x * frameScale * 60;
        chunk.rotation.y += data.spin.y * frameScale * 60;
        chunk.rotation.z += data.spin.z * frameScale * 60;
        chunk.material.opacity = Math.max(0, 0.95 * (1 - lifeRatio));
      }

      // í™œì£¼ë¡œ í…ìŠ¤ì²˜ ìŠ¤í¬ë¡¤(ì „ì§„ê°) - ì¼ì‹œì •ì§€/ì‚¬ë§ ì‹œ ì •ì§€
      if (runwayTex && isActive) {
        // ì†ë„ì— ë¹„ë¡€í•´ì„œ ë” ë¹¨ë¦¬ ìŠ¤í¬ë¡¤ (ì•½í•˜ê²Œ)
        runwayTex.offset.y += (0.006 + speedScale * 0.003) * frameScale;
      }

      // ì—”ì§„ ë¶ˆê½ƒ ì• ë‹ˆë©”ì´ì…˜
      if (player.userData.flame) {
        const f = player.userData.flame;
        const t = now * 0.02;
        const len = 0.85 + Math.sin(t) * 0.05 + Math.random() * 0.03;
        f.scale.set(1, len, 1);
        f.material.emissiveIntensity = 0.8 + Math.random() * 0.3;
        f.material.opacity = 0.55 + Math.random() * 0.15;
      }

      // ì  ì´ë™/ì¶©ëŒ/ì ìˆ˜
      if (isActive) {
        for (const e of enemies) {
          if (!e.visible) continue;
          e.position.z += travelSpeed; // ì¹´ë©”ë¼ ìª½ìœ¼ë¡œ
          // ì¶©ëŒ ì²´í¬ (ë°•ìŠ¤ ì : Yì¶• ìŠ¤ì¼€ì¼ ë°˜ì˜)
          enemyHitbox.copy(e.userData.hitbox || enemyHitbox.set(2.2, 2.2 * e.scale.y, 2.2));
          if (aabbIntersect(player.position, playerSize, e.position, enemyHitbox)) {
            isDead = true;
            isRunning = false;
            best = Math.max(best, Math.floor(score));
            localStorage.setItem("space_dodge_best", String(best));
            document.getElementById("best").textContent = best.toString();
            showCenter(true, "ì¶©ëŒ!", "R: ì¬ì‹œì‘ Â· ìŠ¤í˜ì´ìŠ¤: ì¼ì‹œì •ì§€/ì¬ê°œ");
          }
          if (e.userData.damagePhase > 0) {
            e.userData.damagePhase = Math.max(0, e.userData.damagePhase - frameScale * 3);
            if (e.userData.damagePhase === 0 && e.userData.type) {
              const ratio = Math.max(0, e.userData.hp / e.userData.maxHp);
              e.material.emissiveIntensity = e.userData.type.emissiveIntensity + (1 - ratio) * 0.35;
            }
          }
          // ì§€ë‚˜ê°€ë©´ ì ìˆ˜
          if (!e.userData.passed && e.position.z > player.position.z + 1.5) {
            e.userData.passed = true;
            score += 10 * speedScale;
          }
          // í™”ë©´ ì•ì„ ì§€ë‚˜ë©´ ë¦¬ì…‹
          if (e.position.z > 40) {
            e.visible = false;
            e.position.z = -200;
          }
        }
        // ë‚œì´ë„ ìƒìŠ¹
        speedScale += 0.0006 * frameScale;      // ì²œì²œíˆ ê°€ì†
        // ìŠ¤í° ì£¼ê¸°ë¥¼ ë„ˆë¬´ ì§§ì•„ì§€ì§€ ì•Šê²Œ ìƒí–¥ ì¡°ì •
        spawnEvery = Math.max(320, 550 - speedScale * 45); // ìµœì†Œ ê°„ê²© ìƒí–¥, ê¸°ë³¸ ê°„ê²© ì¦ê°€
        updateHUD();
      }

      // ìŠ¤í° íƒ€ì´ë°
      if (isActive) {
        if (now - lastSpawn > spawnEvery) {
          lastSpawn = now;
          // í•œ ë²ˆì— 1~2ê°œ ìŠ¤í°ìœ¼ë¡œ ëœë¤ì„±
          const batch = Math.random() < 0.05 ? 2 : 1; // 2ê°œ ë™ì‹œ ìŠ¤í° í™•ë¥  ê°ì†Œ
          for (let i = 0; i < batch; i++) spawnEnemy();
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame((t) => { lastTime = t; tick(t); });

    // ë°˜ì‘í˜•
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      const pixelRatio = Math.min(2, window.devicePixelRatio || 1);
      renderer.setPixelRatio(pixelRatio);
      const starMat = stars.material;
      if (starMat && starMat.uniforms && starMat.uniforms.uPixelRatio) {
        starMat.uniforms.uPixelRatio.value = renderer.getPixelRatio();
      }
    });

    // ì²« ì…ë ¥ ì‹œ ë°”ë¡œ ì‹œì‘í•˜ê³  ì‹¶ë‹¤ë©´ ì•„ë˜ ì£¼ì„ í•´ì œ
    // toggleRun();

  </script>
</body>
</html>
