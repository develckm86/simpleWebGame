<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Space War - 3D Flight Prototype</title>
  <style>
    /* 전체 요소 박스 모델을 border-box로 통일 */
    * { box-sizing: border-box; }
    /* 배경과 글꼴, 화면 채우기 스타일 */
    body {
      margin: 0;
      font-family: 'Segoe UI', Helvetica, Arial, sans-serif;
      background: radial-gradient(circle at top, #08111f 0%, #03060c 35%, #010103 100%);
      overflow: hidden;
      color: #d6e4ff;
    }
    /* 조작법 안내 오버레이 상자 */
    #overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 12px 16px;
      background: rgba(5, 12, 24, 0.65);
      border: 1px solid rgba(94, 176, 255, 0.35);
      border-radius: 8px;
      max-width: 280px;
      line-height: 1.45;
      box-shadow: 0 6px 25px rgba(10, 25, 60, 0.45);
      backdrop-filter: blur(6px);
    }
    /* 오버레이 제목 스타일 */
    #overlay h1 {
      margin: 0 0 8px;
      font-size: 18px;
      letter-spacing: 0.04em;
      color: #8fd0ff;
    }
    /* 조작법 리스트 기본 스타일 */
    #overlay ul {
      margin: 0;
      padding-left: 18px;
      font-size: 14px;
    }
    /* 리스트 항목 간격 조절 */
    #overlay li + li {
      margin-top: 4px;
    }
    /* 캔버스를 블록으로 표시해 여백 제거 */
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="overlay">
    <h1>Space Patrol</h1>
    <ul>
      <li>`W / S` 앞으로 · 뒤로 추진</li>
      <li>`A / D` 좌우 요 (Yaw)</li>
      <li>`Arrow Up / Down` 피치 조정</li>
      <li>`Q / E` 롤 회전</li>
      <li>`Shift` 부스터, `Space` 제동</li>
    </ul>
  </div>
  <!-- three.js 모듈 경로를 브라우저에 알려주는 import map -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.1/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // 전체 우주 장면 구성 요소와 비행 파라미터에 사용하는 상수 묶음
    const CONFIG = {
      // 전체 장면의 색상 팔레트
      colors: {
        background: 0x040914, // 렌더러 배경 및 안개와 동일한 색
        fog: 0x040914, // 먼 거리를 흐릿하게 만드는 안개 색
        boundary: 0x6fa8ff, // 경계 와이어 라인 색상
        boundaryGlow: 0x9fd6ff, // 경계 광채 색상
        flameGlow: 0x70e5ff, // 엔진 스프라이트 기본 색
        flameLight: 0x55d4ff, // 엔진 포인트 라이트 색
      },
      // 전체 우주 공간과 충돌 반사에 대한 설정
      world: {
        radius: 10000, // 우주 공간의 기본 반경
        boundaryRotationSpeed: 0.006, // 경계 그물 회전 속도
        flightLimitFactor: 0.9, // 플레이어 이동 제한 반경 비율
        boundaryBounce: 0.55, // 경계 충돌시 반발 계수
      },
      // 안개가 시작하고 끝나는 거리 비율
      fog: {
        nearFactor: 0.39, // 안개가 시작되는 비율 (radius * near)
        farFactor: 0.82, // 안개가 완전히 뿌옇게 되는 비율
      },
      // 별 구름 생성 파라미터
      stars: {
        count: 5000000, // 별 개수
        radiusMin: 120, // 최소 반경
        radiusMaxFactor: 0.7, // 최대 반경을 WORLD_RADIUS의 몇 배로 둘지
        size: 1.4, // 포인트 머티리얼 크기
      },
      // 소행성 군집 배치 파라미터
      asteroids: {
        count: 18, // 소행성 개수
        radiusMin: 1.5, // 최소 소행성 반지름
        radiusMax: 5.5, // 최대 소행성 반지름
        spreadXZFactor: 0.45, // XZ 방향으로 퍼지는 범위 비율
        spreadYFactor: 0.11, // Y 방향으로 퍼지는 범위 비율
      },
      // 경계 광채 렌더링 파라미터
      boundaryGlow: {
        innerScale: 0.98, // 실제 경계보다 약간 작은 반경
        opacity: 0.12, // 광채 투명도
      },
      // 엔진 화염 스프라이트 공통 설정
      flame: {
        baseOpacity: 0.5, // 기본 불빛 투명도
        glowTextureSize: 128, // 캔버스 텍스처 크기
        spriteScale: 0.6, // 기본 스프라이트 스케일
      },
      // 우주선 비행 물리 관련 파라미터
      flight: {
        acceleration: 80, // 전진 기본 가속도
        strafeAcceleration: 12, // 좌우 이동 가속도
        boostMultiplier: 3, // 부스터 적용시 가속 배율
        brakingForce: 24, // 브레이크 힘
        baseMaxSpeed: 42, // 기본 최고 속도
        boostedMaxSpeedFactor: 10, // 스로틀 100%일 때 최고 속도 배율
        accelerationBoostFactor: 3, // 스로틀에 따른 가속도 배율
        damping: 0.985, // 기본 감쇠율
        boostDampingBonus: 0.004, // 부스터 중 감쇠 보정
        turnSpeedDegPerSec: 36, // 초당 회전 속도(도)
        yawAutoStrafeDegPerSec: 36, // 횡이동 자동 요 속도(도)
        bankAccumDegPerSec: 70, // 입력 유지 시 기울기 누적 속도(도)
        bankReturnSmoothing: 2.2, // 기울기 복귀 감쇄 값
        throttleRiseSeconds: 3, // 스로틀 0→1에 걸리는 시간
        throttleFallSeconds: 1.5, // 스로틀 감소 시간
        maxAutoBankAngle: Infinity, // 자동 기울기 제한 (무한)
        strafeVerticalScale: 0.75, // 수직 이동 시 감쇠 비율
        boostSpeedMultiplier: 1.35, // 부스터 시 최고 속도 배율
        cameraFollowLerp: 0.15, // 카메라 추적 보간 비율
        cameraLookAhead: 8, // 카메라가 바라볼 앞쪽 거리
      },
    };

    // 키보드 입력 상태를 추적하고 축 값을 계산하는 관리 클래스
    class InputManager {
      constructor() {
        this.keys = {}; // 현재 눌려 있는 키 상태 맵
        window.addEventListener('keydown', this.handleKeyDown); // 키다운 이벤트 연결
        window.addEventListener('keyup', this.handleKeyUp); // 키업 이벤트 연결
      }

      handleKeyDown = (event) => {
        this.keys[event.code] = true; // 눌린 키 상태 저장
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(event.code)) {
          event.preventDefault();
        }
      };

      handleKeyUp = (event) => {
        this.keys[event.code] = false; // 키 해제 시 상태 제거
      };

      // 특정 키가 눌려있는지 여부 반환
      isPressed(code) {
        return !!this.keys[code];
      }

      // 두 키를 양/음 축으로 삼아 -1~1 범위 값을 계산
      getAxis(positiveCode, negativeCode) {
        return (this.isPressed(positiveCode) ? 1 : 0) - (this.isPressed(negativeCode) ? 1 : 0);
      }
    }

    // 별, 소행성, 경계 그물 등을 생성·업데이트하고 충돌 반사를 담당
    class SpaceEnvironment {
      constructor(scene) {
        this.scene = scene; // three.js 장면 객체
        this.worldRadius = CONFIG.world.radius; // 우주 반경
        this.boundaryRotationSpeed = CONFIG.world.boundaryRotationSpeed; // 경계 회전 속도
        this.flightLimit = this.worldRadius * CONFIG.world.flightLimitFactor; // 이동 제한 반경
        this.flightLimitSq = this.flightLimit * this.flightLimit; // 빠른 비교용 제곱 반경
        this.boundaryBounce = CONFIG.world.boundaryBounce; // 경계 반발 계수

        this.stars = this.createStars(); // 별 구름 포인트 객체
        this.rocks = this.createAsteroids(); // 소행성 그룹
        const { boundaryMesh, boundaryGlow } = this.createBoundary(); // 경계 메쉬/광채 생성
        this.boundaryMesh = boundaryMesh; // 와이어 경계 그물
        this.boundaryGlow = boundaryGlow; // 경계 광채 메쉬
      }

      // 균일한 체적 분포로 별을 생성해 장면에 추가
      createStars() {
        const { count, radiusMin, radiusMaxFactor, size } = CONFIG.stars;
        const maxRadius = this.worldRadius * radiusMaxFactor;
        const geometry = new THREE.BufferGeometry(); // 별 좌표를 담을 버퍼 지오메트리
        const positions = new Float32Array(count * 3); // 위치 배열 (x,y,z)
        const colors = new Float32Array(count * 3); // 색상 배열 (r,g,b)
        const color = new THREE.Color(); // 재사용 가능한 색 객체
        const minCube = radiusMin ** 3; // 최소 반경의 세제곱 (균등 분포용)
        const maxCube = maxRadius ** 3; // 최대 반경의 세제곱
        const diffCube = maxCube - minCube; // 세제곱 범위 차이

        for (let i = 0; i < count; i += 1) { // 모든 별에 대해 위치/색상 계산
          const radius = Math.cbrt(minCube + Math.random() * diffCube); // 균등 체적 분포 반경
          const theta = THREE.MathUtils.randFloat(0, Math.PI * 2); // 무작위 방위각
          const phi = THREE.MathUtils.randFloat(0, Math.PI); // 무작위 분극각
          const sinPhi = Math.sin(phi); // sin(phi) 값 캐시

          positions[i * 3 + 0] = radius * sinPhi * Math.cos(theta); // x 좌표 저장
          positions[i * 3 + 1] = radius * Math.cos(phi); // y 좌표 저장
          positions[i * 3 + 2] = radius * sinPhi * Math.sin(theta); // z 좌표 저장

          const starTint = THREE.MathUtils.randFloat(0.7, 1); // 밝기 랜덤 값
          color.setHSL(THREE.MathUtils.randFloat(0.55, 0.68), THREE.MathUtils.randFloat(0.2, 0.5), starTint); // HSL 색 지정
          color.toArray(colors, i * 3); // 색 배열에 기록
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); // 위치 속성 등록
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); // 색상 속성 등록

        const material = new THREE.PointsMaterial({
          size, // 별 포인트의 기본 크기
          vertexColors: true, // 버텍스 컬러 사용
          transparent: true, // 알파 허용
          opacity: 0.85, // 기본 투명도
          depthWrite: false, // 깊이 버퍼에 쓰지 않음
          sizeAttenuation: true, // 거리 감쇠 활성화
        });

        const stars = new THREE.Points(geometry, material); // 별 포인트 객체 생성
        this.scene.add(stars); // 장면에 추가
        return stars; // 참조 반환
      }

      // 무작위 소행성 군집을 만들어 장면에 배치
      createAsteroids() {
        const group = new THREE.Group(); // 소행성들을 담을 그룹
        const { count, radiusMin, radiusMax, spreadXZFactor, spreadYFactor } = CONFIG.asteroids; // 구성 파라미터 추출
        const spreadXZ = this.worldRadius * spreadXZFactor; // XZ 방향 퍼짐 반경
        const spreadY = this.worldRadius * spreadYFactor; // Y 방향 퍼짐 반경
        const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x585664, roughness: 0.85, metalness: 0.1 }); // 기본 암석 재질

        for (let i = 0; i < count; i += 1) { // 지정된 개수만큼 소행성 생성
          const radius = THREE.MathUtils.randFloat(radiusMin, radiusMax); // 무작위 소행성 크기
          const geom = new THREE.IcosahedronGeometry(radius, THREE.MathUtils.randInt(0, 1)); // 거친 폴리곤 형태
          const mesh = new THREE.Mesh(geom, baseMaterial.clone()); // 재질 복제 후 메쉬 생성
          mesh.position.set(
            THREE.MathUtils.randFloatSpread(spreadXZ * 2), // X 위치
            THREE.MathUtils.randFloatSpread(spreadY * 2), // Y 위치
            THREE.MathUtils.randFloatSpread(spreadXZ * 2), // Z 위치
          );
          mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI); // 임의 회전 값
          mesh.material.color.offsetHSL(THREE.MathUtils.randFloat(-0.05, 0.05), 0, THREE.MathUtils.randFloat(-0.1, 0.1)); // 색조/밝기 변조
          mesh.castShadow = true; // 그림자 생성 허용
          mesh.receiveShadow = true; // 그림자 수신 허용
          mesh.userData.spin = {
            x: THREE.MathUtils.randFloat(-0.35, 0.35),
            y: THREE.MathUtils.randFloat(-0.2, 0.4),
            z: THREE.MathUtils.randFloat(-0.35, 0.35),
          };
          group.add(mesh); // 그룹에 소행성 추가
        }

        this.scene.add(group); // 소행성 그룹을 장면에 등록
        return group; // 생성된 소행성 그룹 반환
      }

      // 와이어 경계와 광채 레이어를 구성해 반환
      createBoundary() {
        const sphere = new THREE.SphereGeometry(this.worldRadius, 22, 16); // 경계 구체 지오메트리
        const wire = new THREE.WireframeGeometry(sphere); // 와이어프레임 변환
        const material = new THREE.LineBasicMaterial({
          color: CONFIG.colors.boundary,
          transparent: true,
          opacity: 0.32,
          depthWrite: false,
          depthTest: false,
        });
        const boundaryMesh = new THREE.LineSegments(wire, material); // 와이어 경계 메쉬
        boundaryMesh.frustumCulled = false; // 항상 렌더링되도록 설정
        this.scene.add(boundaryMesh); // 와이어 경계를 장면에 추가

        const glowGeometry = new THREE.SphereGeometry(this.worldRadius * CONFIG.boundaryGlow.innerScale, 32, 24); // 광채용 구체
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: CONFIG.colors.boundaryGlow,
          transparent: true,
          opacity: CONFIG.boundaryGlow.opacity,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          depthTest: false,
          side: THREE.BackSide,
        });
        const boundaryGlow = new THREE.Mesh(glowGeometry, glowMaterial); // 광채 메쉬 생성
        boundaryGlow.frustumCulled = false; // 항상 렌더링
        this.scene.add(boundaryGlow); // 광채 메쉬를 장면에 추가

        return { boundaryMesh, boundaryGlow }; // 생성된 경계와 광채 메쉬 반환
      }

      // 매 프레임 회전/애니메이션 갱신
      update(delta) {
        this.stars.rotation.y += delta * 0.015; // 별 구름의 천천히 회전

        for (const rock of this.rocks.children) {
          const spin = rock.userData.spin; // 소행성별 회전 속도
          rock.rotation.x += spin.x * delta; // X축 회전
          rock.rotation.y += spin.y * delta; // Y축 회전
          rock.rotation.z += spin.z * delta; // Z축 회전
        }

        this.boundaryMesh.rotation.y += delta * this.boundaryRotationSpeed; // 와이어 경계를 천천히 회전
        this.boundaryGlow.rotation.y -= delta * (this.boundaryRotationSpeed * 0.6); // 광채는 반대 방향으로 회전
      }

      // 이동 제한 반경을 넘으면 위치를 되돌리고 속도를 반사
      enforceBounds(position, velocity) {
        if (position.lengthSq() <= this.flightLimitSq) return;

        const normal = position.clone().normalize(); // 경계 표면 법선 계산
        position.copy(normal.multiplyScalar(this.flightLimit)); // 위치를 경계 표면으로 이동

        const outwardSpeed = velocity.dot(normal); // 경계 밖으로 향하는 속도 성분
        if (outwardSpeed > 0) {
          velocity.addScaledVector(normal, -(1 + this.boundaryBounce) * outwardSpeed); // 반발 계수 적용해 반사
        }
      }
    }

    // 우주선 모델 로딩, 비행 물리, 카메라 및 효과를 관리
    class ShipController {
      constructor(scene, camera, input, environment) {
        this.scene = scene; // 메인 three.js 장면
        this.camera = camera; // 추적할 카메라
        this.input = input; // 입력 관리자 인스턴스
        this.environment = environment; // 환경 제어 객체
        this.flight = CONFIG.flight; // 비행 설정 캐시

        this.group = new THREE.Group(); // 우주선 전체 그룹(위치/회전)
        this.scene.add(this.group); // 우주선 그룹을 장면에 추가
        this.modelRoot = new THREE.Group(); // 실제 glTF 모델이 들어갈 루트
        this.group.add(this.modelRoot); // 루트를 우주선 그룹에 부착

        this.cameraOffset = new THREE.Vector3(0, 1.8, 5.8); // 카메라 오프셋 벡터
        this.cameraTarget = new THREE.Vector3(); // 카메라 추적 위치 계산용
        this.cameraLookAt = new THREE.Vector3(); // 카메라 시선 목표 벡터

        this.velocity = new THREE.Vector3(); // 현재 속도 벡터
        this.forward = new THREE.Vector3(); // 전방 단위 벡터
        this.right = new THREE.Vector3(); // 우측 단위 벡터
        this.up = new THREE.Vector3(0, 1, 0); // 월드 기준 위 방향

        this.rotationState = {
          yaw: 0,
          pitch: 0,
          manualBank: 0,
          autoBank: 0,
          autoBankGoal: 0,
        }; // 누적 회전 정보

        this.throttle = 0; // 현재 스로틀 값(0~1)
        this.throttleRiseRate = 1 / this.flight.throttleRiseSeconds; // 스로틀 증가율
        this.throttleFallRate = 1 / this.flight.throttleFallSeconds; // 스로틀 감소율
        this.turnSpeed = THREE.MathUtils.degToRad(this.flight.turnSpeedDegPerSec); // 요/피치 속도
        this.yawAutoStrafeRate = THREE.MathUtils.degToRad(this.flight.yawAutoStrafeDegPerSec); // 횡이동 자동 요 속도
        this.bankAccumRate = THREE.MathUtils.degToRad(this.flight.bankAccumDegPerSec); // 자동 롤 누적 속도
        this.maxAutoBankAngle = this.flight.maxAutoBankAngle; // 자동 롤 최대치

        this.flameMaterial = new THREE.SpriteMaterial({
          map: createGlowTexture(CONFIG.flame.glowTextureSize), // 광채 텍스처 맵
          color: CONFIG.colors.flameGlow, // 기본 색상 설정
          transparent: true, // 투명도 활성화
          opacity: CONFIG.flame.baseOpacity, // 초기 불빛 세기
          blending: THREE.AdditiveBlending, // 가산 혼합
          depthWrite: false, // 깊이 버퍼에 기록하지 않음
        }); // 엔진 스프라이트 공통 머티리얼
        this.flameSprites = [this.createFlameSprite(), this.createFlameSprite()]; // 좌우 화염 스프라이트
        this.flameLights = [this.createFlameLight(), this.createFlameLight()]; // 좌우 화염 조명

        this.shipBounds = new THREE.Box3(); // 우주선 전체 바운딩 박스
        this.shipSize = new THREE.Vector3(); // 모델 크기 캐시
        this.shipCenter = new THREE.Vector3(); // 모델 중심 캐시
        this.flameCenter = new THREE.Vector3(); // 화염 위치 계산용
        this.modelLoaded = false; // glTF 로딩 완료 여부

        this.ready = this.loadModel(); // glTF 로딩 초기화(비동기)
      }

      // glTF 우주선 모델을 비동기 로드하고 초기 위치/스케일을 맞춘다
      async loadModel() {
        const loader = new GLTFLoader();
        try {
          const gltf = await loader.loadAsync('src/spaceship/scene.gltf');
          const model = gltf.scene || gltf.scenes[0]; // 첫 번째 장면 가져오기
          if (!model) {
            console.warn('GLTF 파일에 장면이 비어 있습니다.');
            return;
          }

          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true; // 그림자 생성 허용
              child.receiveShadow = true; // 그림자 수신 허용
              if (child.material && 'emissiveIntensity' in child.material) {
                child.material.emissiveIntensity *= 1.15; // 발광 강도 강화
              }
            }
          });

          this.shipBounds.setFromObject(model); // 모델 바운딩 박스 계산
          this.shipBounds.getCenter(this.shipCenter); // 중심 좌표 추출
          model.position.sub(this.shipCenter); // 중심을 원점으로 이동

          this.shipBounds.getSize(this.shipSize); // 크기 측정
          const targetLength = 3.5; // 목표 길이
          const maxAxis = Math.max(this.shipSize.x, this.shipSize.y, this.shipSize.z) || 1; // 가장 긴 축
          const scale = targetLength / maxAxis; // 스케일 비율 계산
          model.scale.setScalar(scale); // 균일 스케일 적용

          model.rotation.set(THREE.MathUtils.degToRad(-25), THREE.MathUtils.degToRad(180), 0); // 전진 방향에 맞게 회전

          this.modelRoot.add(model); // 모델을 우주선 루트에 추가

          this.shipBounds.setFromObject(model); // 스케일 적용 후 바운딩 박스 갱신
          this.shipBounds.getSize(this.shipSize); // 크기 재측정
          this.positionFlames(); // 엔진 위치 재배치
          this.modelLoaded = true; // 로드 완료 플래그 설정
        } catch (error) {
          console.error('우주선 모델을 불러오지 못했습니다.', error);
        }
      }

      // 엔진 스프라이트 생성 후 그룹에 추가
      createFlameSprite() {
        const sprite = new THREE.Sprite(this.flameMaterial.clone()); // 공통 머티리얼 복제
        sprite.visible = false; // 모델 로딩 전 숨김
        sprite.scale.setScalar(CONFIG.flame.spriteScale); // 초기 크기 설정
        this.group.add(sprite); // 우주선 그룹에 추가
        return sprite; // 스프라이트 반환
      }

      // 엔진 포인트 조명을 생성
      createFlameLight() {
        const light = new THREE.PointLight(CONFIG.colors.flameLight, 0, 9, 2.2); // 포인트 라이트 생성
        light.visible = false; // 초기에는 숨김 처리
        this.group.add(light); // 우주선 그룹에 추가
        return light; // 참조 반환
      }

      // 로딩된 모델을 기준으로 엔진 위치를 조정
      positionFlames() {
        const exhaustZ = this.shipBounds.max.z + this.shipSize.z * 0.1;
        const center = this.shipBounds.getCenter(this.flameCenter);
        const lateralOffset = Math.max(this.shipSize.x * 0.22, 0.45);
        this.flameSprites.forEach((sprite, index) => {
          const offsetX = index === 0 ? -lateralOffset : lateralOffset; // 좌우 위치 결정
          sprite.position.set(offsetX, center.y, exhaustZ); // 스프라이트 위치 적용
          sprite.visible = true; // 스프라이트 표시
          this.flameLights[index].position.copy(sprite.position); // 광원 위치 동기화
          this.flameLights[index].visible = true; // 광원 표시
        });
      }

      // 매 프레임 입력/물리/카메라/이펙트를 갱신
      update(delta, elapsed) {
        if (!this.modelLoaded) return; // 모델이 로딩되기 전에는 업데이트를 중단

        const input = this.input; // 입력 상태 단축 참조
        const rollInput = input.getAxis('KeyQ', 'KeyE');
        const yawInput = input.getAxis('KeyA', 'KeyD');
        const pitchInput = input.getAxis('ArrowUp', 'ArrowDown');
        const strafeInput = input.getAxis('ArrowRight', 'ArrowLeft');
        const verticalInput = input.getAxis('KeyR', 'KeyF');
        const isBoosting = input.isPressed('ShiftLeft') || input.isPressed('ShiftRight'); // Shift 키로 부스터 여부 확인

        // 스로틀은 W 유지 시 상승하고 키를 떼면 서서히 감소
        if (input.isPressed('KeyW')) {
          this.throttle = Math.min(1, this.throttle + delta * this.throttleRiseRate);
        } else {
          this.throttle = Math.max(0, this.throttle - delta * this.throttleFallRate);
        }

        const currentMaxSpeed = THREE.MathUtils.lerp(
          this.flight.baseMaxSpeed,
          this.flight.baseMaxSpeed * this.flight.boostedMaxSpeedFactor,
          this.throttle,
        ); // 스로틀 비율에 따른 최고 속도 계산
        const currentAcceleration = THREE.MathUtils.lerp(
          this.flight.acceleration,
          this.flight.acceleration * this.flight.accelerationBoostFactor,
          this.throttle,
        ); // 스로틀 비율에 따른 전진 가속도 계산

        // 수동 롤(Q/E) 및 자동 선회 기울기 계산
        this.rotationState.manualBank += rollInput * this.turnSpeed * delta;
        if (Number.isFinite(this.maxAutoBankAngle)) { // 제한 값이 유한한 경우에만 클램프 적용
          this.rotationState.manualBank = THREE.MathUtils.clamp(
            this.rotationState.manualBank,
            -this.maxAutoBankAngle,
            this.maxAutoBankAngle,
          );
        } // 무한대가 아닌 경우에만 롤 각도 제한
        if (rollInput === 0) {
          this.rotationState.manualBank = damp(this.rotationState.manualBank, 0, 4.5, delta); // 입력이 없을 때 서서히 복귀
        }

        const steeringComposite = yawInput + strafeInput * 0.6; // 선회 입력과 횡이동을 합산
        if (steeringComposite !== 0) { // 입력이 유지되는 동안 기울기 목표 누적
          this.rotationState.autoBankGoal += steeringComposite * this.bankAccumRate * delta;
          if (Number.isFinite(this.maxAutoBankAngle)) {
            this.rotationState.autoBankGoal = THREE.MathUtils.clamp(
              this.rotationState.autoBankGoal,
              -this.maxAutoBankAngle,
              this.maxAutoBankAngle,
            );
          }
        } else {
          this.rotationState.autoBankGoal = damp(
            this.rotationState.autoBankGoal,
            0,
            this.flight.bankReturnSmoothing,
            delta,
          );
        }

        this.rotationState.autoBank = damp(
          this.rotationState.autoBank,
          this.rotationState.autoBankGoal,
          6,
          delta,
        );

        const totalBank = Number.isFinite(this.maxAutoBankAngle)
          ? THREE.MathUtils.clamp(
              this.rotationState.manualBank + this.rotationState.autoBank,
              -this.maxAutoBankAngle,
              this.maxAutoBankAngle,
            )
          : this.rotationState.manualBank + this.rotationState.autoBank; // 수동/자동 롤 합산

        this.rotationState.yaw += yawInput * this.turnSpeed * delta; // 직접 입력에 의한 요 회전
        this.rotationState.yaw += -strafeInput * this.yawAutoStrafeRate * delta; // 횡이동에 따른 자동 요 회전

        const pitchTarget = THREE.MathUtils.clamp(
          this.rotationState.pitch + pitchInput * this.turnSpeed * delta,
          -Math.PI / 2.5,
          Math.PI / 2.5,
        ); // 피치 입력을 제한 범위로 클램프
        this.rotationState.pitch = damp(
          this.rotationState.pitch,
          pitchTarget,
          8,
          delta,
        ); // 피치 값을 부드럽게 목표 각도로 보간

        this.group.rotation.set(
          this.rotationState.pitch,
          this.rotationState.yaw,
          totalBank,
        ); // 계산된 자세를 그룹에 적용

        this.forward.set(0, 0, -1).applyQuaternion(this.group.quaternion).normalize(); // 우주선 전방 벡터 업데이트
        this.right.copy(this.forward).cross(this.up).normalize(); // 우측 벡터 계산
        const upDirection = this.right.clone().cross(this.forward).normalize(); // 수직 벡터 계산

        const thrust = (input.isPressed('KeyW') ? currentAcceleration : 0) * (isBoosting ? this.flight.boostMultiplier : 1); // 추진력 계산
        if (thrust > 0) {
          this.velocity.addScaledVector(this.forward, thrust * delta); // 전방 방향으로 가속도 적용
        }

        if (input.isPressed('KeyS')) {
          this.velocity.addScaledVector(this.forward, -this.flight.acceleration * 0.6 * delta); // 후진 입력 처리
        }

        if (input.isPressed('Space')) {
          const currentSpeed = this.velocity.length(); // 현재 속도 크기
          if (currentSpeed > 0.01) {
            const brakeAmount = Math.min(this.flight.brakingForce * delta, currentSpeed); // 브레이크 적용량
            this.velocity.addScaledVector(this.velocity.clone().normalize(), -brakeAmount);
          }
        }

        if (strafeInput !== 0) {
          this.velocity.addScaledVector(
            this.right,
            strafeInput * this.flight.strafeAcceleration * delta,
          ); // 횡이동 속도 추가
        }

        if (verticalInput !== 0) {
          this.velocity.addScaledVector(
            upDirection,
            verticalInput * this.flight.strafeAcceleration * this.flight.strafeVerticalScale * delta,
          ); // 상하 이동 속도 추가
        }

        const maxSpeedMultiplier = isBoosting ? this.flight.boostSpeedMultiplier : 1; // 부스터에 따른 최고 속도 배율
        clampLength(this.velocity, currentMaxSpeed * maxSpeedMultiplier); // 속도 제한 적용
        const appliedDamping = isBoosting
          ? this.flight.damping + this.flight.boostDampingBonus
          : this.flight.damping; // 부스터 여부로 감쇠 조정
        this.velocity.multiplyScalar(appliedDamping); // 감쇠 적용

        this.group.position.addScaledVector(this.velocity, delta); // 속도에 따라 우주선 위치 이동
        this.environment.enforceBounds(this.group.position, this.velocity); // 경계 충돌 처리

        this.cameraTarget.copy(this.cameraOffset).applyQuaternion(this.group.quaternion).add(this.group.position); // 카메라 목표 위치 계산
        this.camera.position.lerp(this.cameraTarget, this.flight.cameraFollowLerp); // 부드러운 카메라 이동

        this.cameraLookAt.copy(this.group.position).addScaledVector(this.forward, this.flight.cameraLookAhead); // 시선 목표 계산
        this.camera.lookAt(this.cameraLookAt); // 카메라 시선 고정

        const thrustPulse = Math.sin(elapsed * 12) * 0.12 + 0.88; // 부드러운 펄스 애니메이션 값
        const glowScale = thrustPulse * (isBoosting ? 1.2 : 0.85); // 펄스 크기 결정
        const targetOpacity = input.isPressed('KeyW') || isBoosting ? 0.9 : 0.32; // 광채 목표 투명도
        const targetIntensity = input.isPressed('KeyW') || isBoosting ? 3.2 : 0.4; // 조명 목표 밝기

        this.flameSprites.forEach((sprite, index) => {
          const scale = Math.max(0.45, glowScale); // 최소 크기 확보 후 스케일 결정
          sprite.scale.set(scale, scale, 1);
          sprite.material.opacity = THREE.MathUtils.lerp(
            sprite.material.opacity,
            targetOpacity,
            0.12,
          ); // 투명도를 서서히 보간
          this.flameLights[index].intensity = THREE.MathUtils.lerp(
            this.flameLights[index].intensity,
            targetIntensity,
            0.18,
          ); // 광원 밝기 보간
        });
      }
    }

    function damp(current, target, smoothing, deltaTime) {
      const factor = 1 - Math.exp(-smoothing * deltaTime); // 감쇠 계수를 계산
      return THREE.MathUtils.lerp(current, target, factor); // 현재 값을 목표 값으로 보간
    }

    function clampLength(vector, max) {
      if (vector.lengthSq() > max * max) { // 현재 길이가 허용치를 넘는지 검사
        vector.setLength(max); // 벡터 길이를 제한 값으로 재설정
      }
    }

    // 부드러운 광채 스프라이트 텍스처를 캔버스로 생성
    function createGlowTexture(size) {
      const canvas = document.createElement('canvas'); // 스프라이트용 캔버스 생성
      canvas.width = canvas.height = size; // 정사각형 크기 설정
      const context = canvas.getContext('2d'); // 2D 컨텍스트 획득
      const gradient = context.createRadialGradient(
        size / 2,
        size / 2,
        size * 0.1,
        size / 2,
        size / 2,
        size * 0.5,
      ); // 중심에서 외곽으로 갈수록 어두워지는 그라디언트 생성
      gradient.addColorStop(0, 'rgba(255,255,255,1)'); // 핵심부 밝게
      gradient.addColorStop(0.35, 'rgba(140,220,255,0.9)'); // 청록색 계열 추가
      gradient.addColorStop(0.7, 'rgba(80,200,255,0.35)'); // 외곽은 투명도 증가
      gradient.addColorStop(1, 'rgba(40,120,240,0)'); // 끝부분 완전 투명
      context.fillStyle = gradient; // 그라디언트를 채우기 색으로 지정
      context.fillRect(0, 0, size, size); // 전체 캔버스 채우기

      const texture = new THREE.CanvasTexture(canvas); // 캔버스를 텍스처로 변환
      if ('colorSpace' in texture) {
        texture.colorSpace = THREE.SRGBColorSpace; // 최신 three.js에 맞춰 색 공간 지정
      } else {
        texture.encoding = THREE.sRGBEncoding; // 구 버전 호환성 처리
      }
      texture.needsUpdate = true; // 텍스처 업데이트 플래그
      return texture; // 완성된 텍스처 반환
    }

    // 렌더러/장면/조명/컨트롤러를 초기화하고 렌더 루프를 시작
    async function init() {
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false }); // WebGL 렌더러 생성
      renderer.setPixelRatio(window.devicePixelRatio); // 고해상도 디스플레이 대응
      renderer.setSize(window.innerWidth, window.innerHeight); // 캔버스 크기 설정
      renderer.setClearColor(CONFIG.colors.background, 1); // 배경색 지정
      if ('outputColorSpace' in renderer) {
        renderer.outputColorSpace = THREE.SRGBColorSpace; // 색 공간을 sRGB로 고정
      }
      renderer.toneMapping = THREE.ACESFilmicToneMapping; // 필름 톤 매핑
      renderer.toneMappingExposure = 1.05; // 노출 보정
      renderer.physicallyCorrectLights = true; // 물리 기반 조명 활성화
      document.body.appendChild(renderer.domElement); // 캔버스를 문서에 추가

      const scene = new THREE.Scene(); // 메인 three.js 장면
      scene.fog = new THREE.Fog(
        CONFIG.colors.fog,
        CONFIG.world.radius * CONFIG.fog.nearFactor,
        CONFIG.world.radius * CONFIG.fog.farFactor,
      ); // 안개 거리 설정

      const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(0, 2.2, 6); // 초기 카메라 위치

      const ambient = new THREE.AmbientLight(0x96b4ff, 0.35); // 부드러운 주변광
      scene.add(ambient);

      const keyLight = new THREE.DirectionalLight(0xffffff, 1.85);
      keyLight.position.set(12, 18, 8); // 메인 라이트 방향 설정
      scene.add(keyLight);

      const rimLight = new THREE.PointLight(0x3a7bff, 1.4, 40, 1.8); // 윤곽 강조용 포인트 라이트
      rimLight.position.set(-6, -2, -4); // 배면 강조 라이트 위치
      scene.add(rimLight);

      const input = new InputManager(); // 키 입력 관리 인스턴스
      const environment = new SpaceEnvironment(scene); // 별/소행성/경계 생성기
      const ship = new ShipController(scene, camera, input, environment); // 우주선 컨트롤러
      await ship.ready; // glTF 모델이 준비될 때까지 대기

      const clock = new THREE.Clock(); // 델타 타이밍 계산용 시계
      const renderLoop = () => { // 매 프레임 호출되는 렌더 루프
        const delta = Math.min(clock.getDelta(), 0.05); // 프레임 시간 상한 적용
        const elapsed = clock.getElapsedTime(); // 경과 시간 추적
        environment.update(delta); // 환경 애니메이션 갱신
        ship.update(delta, elapsed); // 우주선 물리/카메라 갱신
        renderer.render(scene, camera); // 장면 렌더링
        requestAnimationFrame(renderLoop); // 다음 프레임 예약
      };
      renderLoop();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight; // 종횡비 갱신
        camera.updateProjectionMatrix(); // 투영 행렬 재계산
        renderer.setSize(window.innerWidth, window.innerHeight); // 캔버스 크기 조정
      });
    }

    init().catch((error) => {
      console.error('초기화 중 오류가 발생했습니다.', error); // 초기화 실패 시 로깅
    });
  </script>
</body>
</html>
