<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Space Dodge - Three.js</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    html, body { height: 100%; margin: 0; background: #000; color: #e7f0ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #hud {
      position: fixed; inset: 0 auto auto 0; padding: 10px 14px; font-weight: 600; letter-spacing: .3px;
      background: linear-gradient(to right, rgba(0,0,0,.65), rgba(0,0,0,0));
      border-bottom-right-radius: 10px;
    }
    #hud .line { opacity: .9; }
    #hint {
      position: fixed; right: 10px; top: 10px; text-align: right; opacity: .9; line-height: 1.4;
      background: linear-gradient(to left, rgba(0,0,0,.65), rgba(0,0,0,0));
      padding: 10px 14px; border-bottom-left-radius: 10px;
    }
    #centerMsg {
      position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
      text-align: center; font-weight: 800; letter-spacing: .8px;
      background: rgba(0,0,0,.55); padding: 18px 22px; border-radius: 12px; display: none;
      box-shadow: 0 10px 30px rgba(0,0,0,.4);
    }
    #centerMsg h1 { margin: 0 0 8px; font-size: clamp(22px, 4vw, 36px); }
    #centerMsg p { margin: 6px 0; opacity: .9; }
    canvas { display:block; }
    a { color: #8fd3ff; text-decoration: none; }
  </style>
</head>
<body>
  <div id="hud">
    <div class="line">점수: <span id="score">0</span></div>
    <div class="line">최고점수: <span id="best">0</span></div>
    <div class="line">속도: <span id="speed">1.0</span>x</div>
  </div>
  <div id="hint">
    조작: ←/→ 또는 A/D 이동<br/>
    스페이스: 일시정지/재개, R: 재시작
  </div>
  <div id="centerMsg">
    <h1>Space Dodge</h1>
    <p>←/→ 또는 A/D로 좌우 이동</p>
    <p>스페이스: 시작/일시정지 · R: 재시작</p>
  </div>

  <!-- Three.js ES Module CDN -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ----- 기본 세트업 -----
    const canvasContainer = document.body;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.shadowMap.enabled = true;
    canvasContainer.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000010, 50, 400);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 6, 18);
    camera.lookAt(0, 3, 0);

    // 조명
    const hemi = new THREE.HemisphereLight(0x99ccff, 0x223355, 0.9);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(10, 20, 10);
    dir.castShadow = true;
    scene.add(dir);

    // ----- 우주 배경(별 입자) -----
    function createStarfield(count = 1500, depth = 800) {
      const geom = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        positions[i * 3 + 0] = (Math.random() - 0.5) * 200; // x
        positions[i * 3 + 1] = Math.random() * 120 - 20;    // y
        positions[i * 3 + 2] = -Math.random() * depth;      // z (카메라 뒤쪽)
      }
      geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      const mat = new THREE.PointsMaterial({ size: 0.8, color: 0x9ecbff });
      const points = new THREE.Points(geom, mat);
      points.userData = { depth };
      return points;
    }
    const stars = createStarfield();
    scene.add(stars);

    // ----- 플레이어 -----
    const playerSize = new THREE.Vector3(2.2, 2.2, 2.2);
    const playerGeo = new THREE.BoxGeometry(playerSize.x, playerSize.y, playerSize.z);
    const playerMat = new THREE.MeshStandardMaterial({ color: 0x68d5ff, metalness: 0.2, roughness: 0.4 });
    const player = new THREE.Mesh(playerGeo, playerMat);
    player.castShadow = true;
    player.position.set(0, 2.5, 0);
    scene.add(player);

    // 바닥(미세한 반사)
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(300, 1000),
      new THREE.MeshPhongMaterial({ color: 0x021019, shininess: 10, specular: 0x0a3a50 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.z = -300;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // ----- 적 블록 풀 -----
    const ENEMY_POOL_SIZE = 50;
    const enemyGeo = new THREE.BoxGeometry(2.2, 2.2, 2.2);
    const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff5d6c, metalness: 0.1, roughness: 0.6 });
    const enemies = [];
    for (let i = 0; i < ENEMY_POOL_SIZE; i++) {
      const m = new THREE.Mesh(enemyGeo, enemyMat);
      m.castShadow = true;
      m.visible = false;
      m.position.set(0, 2.5, -200);
      scene.add(m);
      enemies.push(m);
    }

    // 스폰 레인(좌표)
    const LANES = [-6, -3, 0, 3, 6];

    // ----- 상태 -----
    let isRunning = false;
    let isDead = false;
    let score = 0;
    let best = Number(localStorage.getItem("space_dodge_best") || 0);
    let baseSpeed = 0.6;      // 적의 기본 전진 속도
    let speedScale = 1.0;     // 시간 경과에 따라 증가
    let spawnEvery = 400;     // 적 생성 간격(ms)
    let lastSpawn = 0;
    let lastTime = performance.now();

    // HUD DOM
    const $score = document.getElementById("score");
    const $best = document.getElementById("best");
    const $speed = document.getElementById("speed");
    const $center = document.getElementById("centerMsg");
    $best.textContent = best.toString();
    showCenter(true);

    // ----- 입력 -----
    const input = { left: false, right: false };
    window.addEventListener("keydown", (e) => {
      if (e.code === "ArrowLeft" || e.code === "KeyA") input.left = true;
      if (e.code === "ArrowRight" || e.code === "KeyD") input.right = true;
      if (e.code === "Space") {
        e.preventDefault();
        toggleRun();
      }
      if (e.code === "KeyR") restart();
    });
    window.addEventListener("keyup", (e) => {
      if (e.code === "ArrowLeft" || e.code === "KeyA") input.left = false;
      if (e.code === "ArrowRight" || e.code === "KeyD") input.right = false;
    });

    function toggleRun() {
      if (isDead) return;
      isRunning = !isRunning;
      showCenter(!isRunning);
    }

    function showCenter(show, title, desc) {
      if (show) {
        if (title) {
          $center.querySelector("h1").textContent = title;
        }
        if (desc) {
          $center.querySelectorAll("p")[0].textContent = desc;
        }
        $center.style.display = "block";
      } else {
        $center.style.display = "none";
      }
    }

    function restart() {
      // 초기화
      isDead = false;
      isRunning = false;
      score = 0;
      speedScale = 1.0;
      baseSpeed = 0.6;
      spawnEvery = 400;
      $score.textContent = "0";
      $speed.textContent = speedScale.toFixed(1) + "x";
      // 적 리셋
      for (const e of enemies) {
        e.visible = false;
        e.position.z = -200;
      }
      // 플레이어 위치
      player.position.x = 0;
      showCenter(true, "Space Dodge", "←/→ 또는 A/D로 좌우 이동");
    }

    // ----- 유틸 -----
    function spawnEnemy() {
      const e = enemies.find(o => !o.visible);
      if (!e) return;
      e.visible = true;
      const laneX = LANES[Math.floor(Math.random() * LANES.length)];
      const sizeY = 1.8 + Math.random() * 2.2;   // 약간 다양한 높이
      e.scale.set(1, sizeY / 2.2, 1);
      e.position.set(laneX, 2.5, -280 - Math.random() * 60);
      e.userData.passed = false;
    }

    function aabbIntersect(aPos, aSize, bPos, bSize) {
      return Math.abs(aPos.x - bPos.x) * 2 < (aSize.x + bSize.x) &&
             Math.abs(aPos.y - bPos.y) * 2 < (aSize.y + bSize.y) &&
             Math.abs(aPos.z - bPos.z) * 2 < (aSize.z + bSize.z);
    }

    function updateHUD() {
      $score.textContent = Math.floor(score).toString();
      $speed.textContent = speedScale.toFixed(1) + "x";
    }

    // ----- 메인 루프 -----
    function tick(now) {
      const dt = Math.min(50, now - lastTime); // ms
      lastTime = now;

      // 별 이동(카메라 쪽으로)
      const starPos = stars.geometry.attributes.position;
      const depth = stars.userData.depth;
      for (let i = 0; i < starPos.count; i++) {
        const z = starPos.getZ(i) + (0.08 + speedScale * 0.04) * (dt / 16.67);
        if (z > 10) {
          starPos.setZ(i, -Math.random() * depth - 100);
          starPos.setX(i, (Math.random() - 0.5) * 200);
        } else {
          starPos.setZ(i, z);
        }
      }
      starPos.needsUpdate = true;

      // 입력에 따른 플레이어 좌우 이동
      if (isRunning && !isDead) {
        const move = 0.02 * dt * 0.6 * (1 + (speedScale - 1) * 0.2);
        if (input.left)  player.position.x -= move;
        if (input.right) player.position.x += move;
        // 레일 범위 제한
        player.position.x = Math.max(-7.5, Math.min(7.5, player.position.x));
      }

      // 적 이동/충돌/점수
      if (isRunning && !isDead) {
        const enemySpeed = (baseSpeed + speedScale * 0.4) * (dt / 16.67);
        for (const e of enemies) {
          if (!e.visible) continue;
          e.position.z += enemySpeed; // 카메라 쪽으로
          // 충돌 체크
          if (aabbIntersect(player.position, playerSize, e.position, new THREE.Vector3(2.2, 2.2 * e.scale.y, 2.2))) {
            isDead = true;
            isRunning = false;
            best = Math.max(best, Math.floor(score));
            localStorage.setItem("space_dodge_best", String(best));
            document.getElementById("best").textContent = best.toString();
            showCenter(true, "충돌!", "R: 재시작 · 스페이스: 일시정지/재개");
          }
          // 지나가면 점수
          if (!e.userData.passed && e.position.z > player.position.z + 1.5) {
            e.userData.passed = true;
            score += 10 * speedScale;
          }
          // 화면 앞을 지나면 리셋
          if (e.position.z > 40) {
            e.visible = false;
            e.position.z = -200;
          }
        }
        // 난이도 상승
        speedScale += 0.0006 * (dt / 16.67);      // 천천히 가속
        spawnEvery = Math.max(160, 400 - speedScale * 50); // 최대치 제한
        updateHUD();
      }

      // 스폰 타이밍
      if (isRunning && !isDead) {
        if (now - lastSpawn > spawnEvery) {
          lastSpawn = now;
          // 한 번에 1~2개 스폰으로 랜덤성
          const batch = Math.random() < 0.15 ? 2 : 1;
          for (let i = 0; i < batch; i++) spawnEnemy();
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame((t) => { lastTime = t; tick(t); });

    // 반응형
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 첫 입력 시 바로 시작하고 싶다면 아래 주석 해제
    // toggleRun();

  </script>
</body>
</html>