<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Space War - 3D Flight Prototype</title>
  <style>
    /* 전체 요소 박스 모델을 border-box로 통일 */
    * { box-sizing: border-box; }
    /* 배경과 글꼴, 화면 채우기 스타일 */
    body {
      margin: 0;
      font-family: 'Segoe UI', Helvetica, Arial, sans-serif;
      background: radial-gradient(circle at top, #08111f 0%, #03060c 35%, #010103 100%);
      overflow: hidden;
      color: #d6e4ff;
    }
    /* 조작법 안내 오버레이 상자 */
    #overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 12px 16px;
      background: rgba(5, 12, 24, 0.65);
      border: 1px solid rgba(94, 176, 255, 0.35);
      border-radius: 8px;
      max-width: 280px;
      line-height: 1.45;
      box-shadow: 0 6px 25px rgba(10, 25, 60, 0.45);
      backdrop-filter: blur(6px);
    }
    /* 오버레이 제목 스타일 */
    #overlay h1 {
      margin: 0 0 8px;
      font-size: 18px;
      letter-spacing: 0.04em;
      color: #8fd0ff;
    }
    /* 조작법 리스트 기본 스타일 */
    #overlay ul {
      margin: 0;
      padding-left: 18px;
      font-size: 14px;
    }
    /* 리스트 항목 간격 조절 */
    #overlay li + li {
      margin-top: 4px;
    }
    /* 캔버스를 블록으로 표시해 여백 제거 */
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="overlay">
    <h1>Space Patrol</h1>
    <ul>
      <li>`W / S` 앞으로 · 뒤로 추진</li>
      <li>`A / D` 좌우 요 (Yaw)</li>
      <li>`Arrow Up / Down` 피치 조정</li>
      <li>`Q / E` 롤 회전</li>
      <li>`Shift` 부스터, `Space` 제동</li>
    </ul>
  </div>
  <!-- three.js 모듈 경로를 브라우저에 알려주는 import map -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.1/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    // Three.js와 glTF 로더를 CDN 모듈로 가져온다
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // 우주 장면을 그릴 WebGL 렌더러 초기화
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x030611, 1); // 깊은 우주색 배경
    if ('outputColorSpace' in renderer) {
      renderer.outputColorSpace = THREE.SRGBColorSpace;
    }
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05; // 약간 밝게 보정
    renderer.physicallyCorrectLights = true;
    document.body.appendChild(renderer.domElement);

    // 3D 객체를 담을 장면 생성
    const scene = new THREE.Scene();

    // 플레이어 시점을 담당할 카메라 설정
    const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 2000); // 넓은 시야각과 긴 투영 거리
    camera.position.set(0, 2.2, 6); // 우주선 뒤·위에서 시작 위치

    // 기본 조명을 배치해 모델을 보기 좋게 만든다
    const ambient = new THREE.AmbientLight(0x96b4ff, 0.35); // 은은한 파란색 주변광
    scene.add(ambient);

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.85); // 메인 라이트, 꽤 밝은 강도
    keyLight.position.set(12, 18, 8); // 우측 상단에서 비추도록 배치
    scene.add(keyLight);

    // 우주선 윤곽을 강조할 보조 조명
    const rimLight = new THREE.PointLight(0x3a7bff, 1.4, 40, 1.8); // 파란 테두리 강조 조명
    rimLight.position.set(-6, -2, -4); // 좌측 뒤쪽에서 살짝 비춰 윤곽을 강조
    scene.add(rimLight);

    // 이동/회전에 사용할 우주선 루트 그룹
    const ship = new THREE.Group();
    scene.add(ship);

    // 실제 모델을 담을 보조 그룹
    const shipModel = new THREE.Group();
    ship.add(shipModel);

    // 엔진 화염 이펙트(모델 로딩 후 위치 조정 예정)
    const flameTexture = createGlowTexture();
    const flameBaseMaterial = new THREE.SpriteMaterial({
      map: flameTexture,
      color: 0x70e5ff,
      transparent: true,
      opacity: 0.5,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    }); // 밝은 청록색 광채
    const flameMeshes = [createFlame(), createFlame()]; // 좌우 두 개의 분사구
    const flameLights = [createFlameLight(), createFlameLight()];

    function createFlame() {
      const material = flameBaseMaterial.clone();
      material.opacity = flameBaseMaterial.opacity;
      const sprite = new THREE.Sprite(material);
      sprite.visible = false;
      sprite.scale.setScalar(0.6);
      ship.add(sprite);
      return sprite;
    }

    function createGlowTexture() {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const context = canvas.getContext('2d');
      const gradient = context.createRadialGradient(
        size / 2,
        size / 2,
        size * 0.1,
        size / 2,
        size / 2,
        size * 0.5,
      );
      gradient.addColorStop(0, 'rgba(255,255,255,1)');
      gradient.addColorStop(0.35, 'rgba(140,220,255,0.9)');
      gradient.addColorStop(0.7, 'rgba(80,200,255,0.35)');
      gradient.addColorStop(1, 'rgba(40,120,240,0)');
      context.fillStyle = gradient;
      context.fillRect(0, 0, size, size);

      const texture = new THREE.CanvasTexture(canvas);
      if ('colorSpace' in texture) {
        texture.colorSpace = THREE.SRGBColorSpace;
      } else {
        texture.encoding = THREE.sRGBEncoding;
      }
      texture.needsUpdate = true;
      return texture;
    }

    function createFlameLight() {
      const light = new THREE.PointLight(0x55d4ff, 0, 9, 2.2); // 부드러운 청색 포인트 조명
      light.visible = false;
      ship.add(light);
      return light;
    }


    function positionFlames(bounds) {
      const exhaustZ = bounds.max.z + shipSize.z * 0.10; // 우주선 끝에서 조금 뒤에 화염 배치
      const center = bounds.getCenter(flameCenter);
      const lateralOffset = Math.max(shipSize.x * 0.22, 0.45); // 좌우 분사구 간 거리
      flameMeshes.forEach((mesh, index) => {
        const offsetX = index === 0 ? -lateralOffset : lateralOffset;
        mesh.position.set(offsetX, center.y, exhaustZ);
        mesh.scale.setScalar(0.6);
        mesh.visible = true;
        flameLights[index].position.copy(mesh.position);
        flameLights[index].visible = true;
      });
    }

    // glTF 로딩과 크기 조정을 위한 보조 객체들
    const loader = new GLTFLoader();
    const shipBounds = new THREE.Box3();
    const shipSize = new THREE.Vector3();
    const shipCenter = new THREE.Vector3();
    const flameCenter = new THREE.Vector3();

    // 우주선 모델을 불러와 중심/스케일을 정렬하고 화염 위치를 맞춘다
    loader.load(
      'src/spaceship/scene.gltf',
      (gltf) => {
        const model = gltf.scene || gltf.scenes[0];
        if (!model) {
          console.warn('GLTF 파일에 장면이 비어 있습니다.');
          return;
        }

        // 메시가 가진 그림자/발광 속성을 조정
        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            if (child.material && 'emissiveIntensity' in child.material) {
              child.material.emissiveIntensity *= 1.15;
            }
          }
        });

        // 모델 중심을 원점으로 이동시켜 회전 기준을 맞춤
        shipBounds.setFromObject(model);
        shipBounds.getCenter(shipCenter);
        model.position.sub(shipCenter);

        shipBounds.getSize(shipSize);
        const targetLength = 3.5; // 모델 최대 길이를 3.5단위로 맞춤
        const maxAxis = Math.max(shipSize.x, shipSize.y, shipSize.z) || 1;
        const scale = targetLength / maxAxis;
        model.scale.setScalar(scale);

        // 모델 정면을 180° 회전시켜 전방(-Z)과 일치시키고 머리를 약간 내려준다
        model.rotation.set(THREE.MathUtils.degToRad(-20), THREE.MathUtils.degToRad(180), 0);

        shipModel.add(model);

        shipBounds.setFromObject(model);
        shipBounds.getSize(shipSize);

        // 두 개의 화염 위치를 엔진 끝으로 맞추고 표시
        positionFlames(shipBounds);
      },
      undefined,
      (error) => {
        console.error('우주선 모델을 불러오지 못했습니다.', error);
      },
    );

    // 별 배경 생성을 위한 버퍼 지오메트리와 색상 배열
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 2400; // 넓은 공간감을 위한 총 별 개수
    const starPositions = new Float32Array(starCount * 3);
    const starColors = new Float32Array(starCount * 3);
    const color = new THREE.Color();

    // 구 모양으로 별 좌표와 색상을 무작위 생성
    for (let i = 0; i < starCount; i += 1) {
      const radius = THREE.MathUtils.randFloat(120, 420); // 최소 120~최대 420유닛 거리에서 배치
      const theta = THREE.MathUtils.randFloat(0, Math.PI * 2); // 수평 각도
      const phi = THREE.MathUtils.randFloat(0, Math.PI); // 수직 각도

      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);

      starPositions[i * 3 + 0] = x;
      starPositions[i * 3 + 1] = y;
      starPositions[i * 3 + 2] = z;

      const starTint = THREE.MathUtils.randFloat(0.7, 1); // 밝기 랜덤화
      color.setHSL(THREE.MathUtils.randFloat(0.55, 0.68), THREE.MathUtils.randFloat(0.2, 0.5), starTint);
      color.toArray(starColors, i * 3);
    }

    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
    starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));

    // 별을 렌더링할 포인트 머티리얼
    const starMaterial = new THREE.PointsMaterial({
      size: 1.4, // 화면 거리에 따라 축소되는 별 크기
      vertexColors: true,
      transparent: true,
      opacity: 0.85, // 살짝 투명
      depthWrite: false,
      sizeAttenuation: true,
    });

    // 완성된 별 구름을 장면에 추가
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    // 소행성 군집을 위한 머티리얼과 그룹
    const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x585664, roughness: 0.85, metalness: 0.1 }); // 거친 암석 재질
    const rocks = new THREE.Group();
    scene.add(rocks);

    // 랜덤 크기와 위치의 소행성을 생성
    for (let i = 0; i < 18; i += 1) { // 18개의 소행성 생성
      const radius = THREE.MathUtils.randFloat(1.5, 5.5); // 소행성 반지름 범위
      const geom = new THREE.IcosahedronGeometry(radius, THREE.MathUtils.randInt(0, 1));
      const mesh = new THREE.Mesh(geom, rockMaterial.clone());
      mesh.position.set(
        THREE.MathUtils.randFloatSpread(180),
        THREE.MathUtils.randFloatSpread(80),
        THREE.MathUtils.randFloatSpread(180),
      );
      mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      mesh.material.color.offsetHSL(THREE.MathUtils.randFloat(-0.05, 0.05), 0, THREE.MathUtils.randFloat(-0.1, 0.1)); // 약간씩 색조·명도 변화를 줌
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      // 각 소행성에 고유 회전 속도를 부여
      mesh.userData.spin = {
        x: THREE.MathUtils.randFloat(-0.35, 0.35),
        y: THREE.MathUtils.randFloat(-0.2, 0.4),
        z: THREE.MathUtils.randFloat(-0.35, 0.35),
      };
      rocks.add(mesh);
    }

    // 프레임 시간과 키 입력 상태를 추적
    const clock = new THREE.Clock();
    const keys = {};

    // 키를 누르면 상태를 true로 바꾸고 방향키의 기본 동작을 막음
    window.addEventListener('keydown', (event) => {
      keys[event.code] = true;
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(event.code)) {
        event.preventDefault();
      }
    });

    // 키를 떼면 상태를 false로 복구
    window.addEventListener('keyup', (event) => {
      keys[event.code] = false;
    });

    // 이동 계산과 카메라 추적에 사용할 벡터들
    const velocity = new THREE.Vector3();
    const forwardVector = new THREE.Vector3();
    const rightVector = new THREE.Vector3();
    const upVector = new THREE.Vector3(0, 1, 0);
    const cameraOffset = new THREE.Vector3(0, 1.8, 5.8); // 우주선 뒤쪽에서 추적할 상대 위치
    const cameraTarget = new THREE.Vector3();
    const cameraLookAt = new THREE.Vector3();

    // 비행 조작감을 조절하는 파라미터 모음
    const acceleration = 22; // 전진 가속도
    const strafeAcceleration = 12; // 좌우 이동 가속도
    const boostMultiplier = 1.8; // 부스터 배율
    const brakingForce = 24; // 스페이스바 제동력
    const maxSpeed = 42; // 기본 최고 속도
    const damping = 0.985; // 속도 감쇠율(마찰)
    const turnSpeed = THREE.MathUtils.degToRad(60); // 초당 60도 회전 속도

    // 속도 벡터가 한계를 넘지 않도록 조정
    function clampLength(vector, max) {
      if (vector.lengthSq() > max * max) {
        vector.setLength(max);
      }
    }

    // 매 프레임 호출되어 물리와 렌더링을 처리
    function animate() {
      const delta = Math.min(clock.getDelta(), 0.05); // 초당 20fps 이하로 떨어질 때 물리 폭주 방지
      const elapsed = clock.getElapsedTime();

      // 별과 소행성에 약간씩 움직임을 줘서 장면에 생동감을 부여
      stars.rotation.y += delta * 0.015;

      for (const rock of rocks.children) {
        const spin = rock.userData.spin;
        rock.rotation.x += spin.x * delta;
        rock.rotation.y += spin.y * delta;
        rock.rotation.z += spin.z * delta;
      }

      // 키 입력을 바탕으로 회전량을 계산
      const rollInput = (keys['KeyQ'] ? 1 : 0) - (keys['KeyE'] ? 1 : 0);
      const yawInput = (keys['KeyA'] ? 1 : 0) - (keys['KeyD'] ? 1 : 0);
      const pitchInput = (keys['ArrowUp'] ? 1 : 0) - (keys['ArrowDown'] ? 1 : 0);

      ship.rotation.z += rollInput * turnSpeed * delta;
      ship.rotation.y += yawInput * turnSpeed * delta;
      ship.rotation.x = THREE.MathUtils.clamp(ship.rotation.x + pitchInput * turnSpeed * delta, -Math.PI / 2.5, Math.PI / 2.5);

      // 현재 우주선의 방향 벡터 계산
      forwardVector.set(0, 0, -1).applyQuaternion(ship.quaternion).normalize();
      rightVector.copy(forwardVector).cross(upVector).normalize();
      const upDirection = rightVector.clone().cross(forwardVector).normalize();

      // 추진, 브레이크, 부스터 입력 처리
      const isBoosting = keys['ShiftLeft'] || keys['ShiftRight'];
      const thrust = (keys['KeyW'] ? acceleration : 0) * (isBoosting ? boostMultiplier : 1); // 기본 추진력 × 부스터
      const braking = keys['Space'] ? brakingForce : 0; // 제동 입력 시 감속량

      if (thrust > 0) {
        velocity.addScaledVector(forwardVector, thrust * delta);
      }

      if (keys['KeyS']) {
        velocity.addScaledVector(forwardVector, -acceleration * 0.6 * delta); // 후진은 60% 힘으로 적용
      }

      if (braking > 0) {
        const currentSpeed = velocity.length();
        if (currentSpeed > 0.01) { // 속도가 거의 0이 되면 멈춤
          const brakeAmount = Math.min(braking * delta, currentSpeed); // 과도한 감속 방지
          velocity.addScaledVector(velocity.clone().normalize(), -brakeAmount);
        }
      }

      // 좌우/상하 이동 입력 반영
      const strafeInput = (keys['ArrowRight'] ? 1 : 0) - (keys['ArrowLeft'] ? 1 : 0);
      if (strafeInput !== 0) {
        velocity.addScaledVector(rightVector, strafeInput * strafeAcceleration * delta);
      }

      const verticalInput = (keys['KeyR'] ? 1 : 0) - (keys['KeyF'] ? 1 : 0);
      if (verticalInput !== 0) {
        velocity.addScaledVector(upDirection, verticalInput * strafeAcceleration * 0.75 * delta); // 상하 이동은 좌우보다 조금 느리게
      }

      // 속도 제한과 감속 적용
      clampLength(velocity, maxSpeed * (isBoosting ? 1.35 : 1)); // 부스터 시 최고속 약 35% 증가
      const appliedDamping = isBoosting ? damping + 0.004 : damping; // 부스터 중 감쇠를 소폭 완화
      velocity.multiplyScalar(appliedDamping);

      // 우주선 위치 갱신
      ship.position.addScaledVector(velocity, delta);

      // 카메라를 우주선 뒤에서 따라가도록 보간
      cameraTarget.copy(cameraOffset).applyQuaternion(ship.quaternion).add(ship.position);
      camera.position.lerp(cameraTarget, 0.15); // 현재 위치에서 목표 위치로 15%씩 보간

      cameraLookAt.copy(ship.position).addScaledVector(forwardVector, 8); // 시선 대상은 우주선 앞쪽 8유닛
      camera.lookAt(cameraLookAt);
      // 원하는 광채 느낌에 맞춰 더 밝거나 작게 하고 싶다면 glowScale, targetOpacity, targetIntensity 값을 살짝씩 조절해보세요.
      // 엔진 광채의 크기와 밝기를 입력에 따라 조절
      const thrustPulse = Math.sin(elapsed * 12) * 0.12 + 0.88; // 초당 12회 맥동으로 엔진 흔들림
      const glowScale = thrustPulse * (isBoosting ? 1.2 : 0.85);
      const targetOpacity = keys['KeyW'] || isBoosting ? 0.9 : 0.32;
      const targetIntensity = keys['KeyW'] || isBoosting ? 3.2 : 0.4;

      flameMeshes.forEach((sprite, index) => {
        const scale = Math.max(0.45, glowScale);
        sprite.scale.set(scale, scale, 1); // 화염 기둥 대신 둥근 광채 크기 조절
        sprite.material.opacity = THREE.MathUtils.lerp(sprite.material.opacity, targetOpacity, 0.12);
        flameLights[index].intensity = THREE.MathUtils.lerp(flameLights[index].intensity, targetIntensity, 0.18);
      });

      // 장면 렌더링 후 다음 프레임을 예약
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // 렌더 루프 시작
    animate();

    // 창 크기가 바뀔 때 투영과 렌더러 크기를 재조정
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
